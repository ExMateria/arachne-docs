{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Arachne's documentation site! Here you will find everything you need to start using Arachne, as well as reference and API documentation.\n\n\nWhat is Arachne?\n\n\n\nArachne is a web framework for Clojure. It aims to be more than a collection of libraries, and provide a coherent, extensible skeleton for rapid development of robust, industrial-scale web applications.\n\n\nIt intends to exhibit the following qualities:\n\n\n\n\nModularity. Each aspect of Arachne's functionality is delivered as a separate module.\n\n\nCohesion. Despite being highly modular, each module exposes clear integration points, allowing modules to build on eachother to deliver highly sophisticated composite behavior.\n\n\nData-driven. Each Arachne application is, at heart, a database specifying what programmatic entities exist and how they are linked.\n\n\n\n\nQuick Start\n\n\n\nArachne provides a basic command-line project generator tool that you can use to create projects. To install this tool, simply download the shell script, place it somewhere on your system path (\n~/bin\n is usually good), and \nchmod\n it to be executable.\n\n\nURL=\nhttps://raw.githubusercontent.com/arachne-framework/arachne-proj-gen/release/arachne.sh\n\ncurl $URL \n ~/bin/arachne\nchmod +x ~/bin/arachne\n\n\n\n\nThen, you can call it anywhere to create a new project, using the syntax \narachne new \nproject-name\n \ntemplate\n, where the project name is a \nfully qualified\n Clojure symbol, and the template is the Git URI of a template repository.\n\n\nThe namespace portion of the project name tells Arachne what kind of namespace structure to use for your project.\n\n\nA good template to get started with is the \nenterprise-spa\n, which sets up a robust single-page Arachne that uses Leiningen, Datomic, ClojureScript, Figwheel and Rum.\n\n\nFor example:\n\n\narachne new my.org/myapp git@github.com:arachne-framework/enterprise-spa.git\n\n\n\n\nThat's it! You've generated a project into a directory named \nmyapp\n. You can open up your favorite editor and start hacking, or run it right away:\n\n\ncd myapp\nlein run :my.org/myapp :my.org.myapp/runtime\n\n\n\n\nYou'll see it compile some ClojureScript, and then you can try it out by hitting \nhttp://localhost:8080\n in your browser.\n\n\nNote that the \nenterprise-spa\n template includes support for SCSS/SASS out of the box; the system will fail to start unless you have the \nsassc\n program installed and available on your path. \nsassc\n is readily available via your system's package manager.\n\n\nTutorials\n\n\n\nThe above technique lets you get started quickily, but if you want to actually understand what's going on you'll probably want to try out the tutorials. These build a similar project, but break it down step by step and explain every concept as it appears.\n\n\n\n\ncreating a new project\n\n\nhandling HTTP requests\n\n\nusing dependency injection\n\n\nusing request interceptors\n\n\nserving static assets\n\n\ncompiling ClojureScript\n\n\ndynamic ClojureScript development with Figwheel\n\n\n\n\nArchitectural Overview\n\n\n\nSee the \noverview\n for a high-level view of Arachne's architecture, and an explanation of how all the pieces fit together.\n\n\nModules\n\n\n\nArachne isn't a monolithic project; it is composed of many small modules, each designed to offer a vertically-integrated set of functionality.\n\n\nAll Arachne applications are built by assembling a selection of suitable modules, both from \"official\" modules and third-party modules. In fact, all Arachne projects are \nthemselves\n modules and can be required by other Arachne projects.\n\n\nArachne's core modules include:\n\n\n\n\narachne-core\n - boostrap Arachne itself\n\n\narachne-http\n - definitions and tools for dealing with basic web concepts\n\n\narachne-pedestal\n - a Pedestal-based HTTP server\n\n\narachne-assets\n - generic asset transformation pipeline\n\n\narachne-cljs\n - tools to compile ClojureScript (as part of an asset pipeline)\n\n\narachne-figwheel\n - Figwheel server for rapid, iterative ClojureScript development\n\n\n\n\nVisit these module's documentation pages for a detailed explanation of the concepts that they define, and how to use them in the context of a project.\n\n\nContributing\n\n\n\nAlthough we're still in an early alpha phase, contributions are welcome! Please see our \nContributing Guide\n to see how you can get involved.", 
            "title": "Home"
        }, 
        {
            "location": "/versions/", 
            "text": "Development Versions\n\n\nThis page lists the most recent development versions of the Arachne artifacts. These versions are guaranteed to have passed their test suite, but are otherwise experimental and may be broken in subtle ways.\n\n\n[org.arachne-framework/arachne-core \narachne-core-version\n]\n[org.arachne-framework/arachne-http \narachne-http-version\n]\n[org.arachne-framework/arachne-pedestal \narachne-pedestal-version\n]\n[org.arachne-framework/arachne-assets \narachne-assets-version\n]\n[org.arachne-framework/pedestal-assets \npedestal-assets-version\n]\n[org.arachne-framework/arachne-cljs \narachne-cljs-version\n]\n[org.arachne-framework/arachne-figwheel \narachne-figwheel-version\n]\n[org.arachne-framework/arachne-sass \narachne-sass-version\n]\n\n\n\n\nNote that to use these artifacts, you will need to add the Arachne maven repository to your project. With Leiningen, it looks something like this:\n\n\n  :repositories [[\narachne-dev\n\n                  \nhttp://maven.arachne-framework.org/artifactory/arachne-dev\n]])", 
            "title": "Versions"
        }, 
        {
            "location": "/versions/#development-versions", 
            "text": "This page lists the most recent development versions of the Arachne artifacts. These versions are guaranteed to have passed their test suite, but are otherwise experimental and may be broken in subtle ways.  [org.arachne-framework/arachne-core  arachne-core-version ]\n[org.arachne-framework/arachne-http  arachne-http-version ]\n[org.arachne-framework/arachne-pedestal  arachne-pedestal-version ]\n[org.arachne-framework/arachne-assets  arachne-assets-version ]\n[org.arachne-framework/pedestal-assets  pedestal-assets-version ]\n[org.arachne-framework/arachne-cljs  arachne-cljs-version ]\n[org.arachne-framework/arachne-figwheel  arachne-figwheel-version ]\n[org.arachne-framework/arachne-sass  arachne-sass-version ]  Note that to use these artifacts, you will need to add the Arachne maven repository to your project. With Leiningen, it looks something like this:    :repositories [[ arachne-dev \n                   http://maven.arachne-framework.org/artifactory/arachne-dev ]])", 
            "title": "Development Versions"
        }, 
        {
            "location": "/architecture/", 
            "text": "Configuration\n\n\nArachne is fundamentally data driven, and Arachne's architecture may be viewed as an experiment in taking a \"data-driven\" approach to its logical extreme.\n\n\nEvery Arachne application is defined, first and foremost, by its \nconfiguration\n. The configuration defines every aspect of the application. This includes not only things that are traditionally \"config\" values like URLs, ports and connection info, but also much more fundamental aspects of the application including:\n\n\n\n\nDependency injection\n\n\nHTTP Routes and endpoints\n\n\nDatabase migrations\n\n\nAsset processing\n\n\nAnything else that can possibly be represented as data.\n\n\n\n\nBecause the configuration is so central to an Arachne app, it needs to be both easy and powerful to query and manipulate. To this end, the configuration is implemented as a full featured, in-memory \nDatomic\n (or \nDataScript\n) database.\n\n\nSchema\n\n\nConfigurations have a schema, which is assembled from the schema of the included \nmodules\n. This schema is Datomic schema, enhanced with additional meta-attributes to provide a robust \nentity type\n model inspired by ontology definition languages such as \nOWL\n.\n\n\nThe configuration schema is intended to define the \nconcepts\n that can exist in an application, and the possible relationships between them.\n\n\nSo, while an Arachne configuration database describes a particular application in great detail, the configuration \nschema\n defines the set of \npossible\n applications for a given set of modules, and the choices that are available to application authors.\n\n\nConfig Initialization\n\n\nWhile a Datomic database is very powerful and has a great many virtues, being readable in its raw form is not one of them. Transaction data for complex entity structures is verbose and not very human friendly.\n\n\nIn order to fulfill its goal of being easy to use, Arachne provides a \nconfiguration DSL\n that allows users to write simple, idiomatic Clojure forms that incrementaly build an application configuration. In essence, these \nconfiguration scripts\n are a small Clojure program that writes the configuration, and the configuration is handed over to the \nruntime\n to be started once it is complete.\n\n\nRuntime\n\n\nA configuration is just data in a database. It doesn't actually \ndo\n anything until it is used to initialize an Arachne runtime.\n\n\nConfiguration databases contain \ncomponent\n entities. Component entities are database entities that correspond with actual software objects in a running application. Component entities define two important pieces of information:\n\n\n\n\nRefs to other component entities (their \ndependencies\n)\n\n\nThe fully-qualified name of a Clojure function that can be called to obtain an instance of the component.\n\n\n\n\nWhen the runtime is started, it searches for all the component entities in the configuration, and builds a dependency graph. It then calls each component's constructor function to obtain an actual instance.\n\n\nComponents may be of any type, although it is required that they support Clojure's \nclojure.lang.IPersistentMap\n protocol (i.e, be a map or a record) if they are to have any dependencies, since dependencies are added by \nassoc\ning a keyword.\n\n\nComponent objects may also satisfy the \ncom.stuartsierra.Lifecycle\n protocol from Stuart Sierra's \"Component\" library), implementing \nstart\n and \nstop\n methods that will be called when the system is started and stopped, respectively.\n\n\nFinally, the runtime wires each component together with its dependencies, and calls \nstart\n on each of them in dependency order. At this point, the full Arachne system is running.\n\n\nNote that an Arachne runtime is based off a single configuration \nvalue\n. The configuration itself is immutable at that point. If the configuration needs to be changed, then a new runtime needs to be constructed.\n\n\nModules\n\n\nArachne is not a monolithic library. Any Arachne application is built from many different \nmodules\n, each implementing some feature set or providing some particular functionality. Some modules, such as the base \narachne-core\n or \narachne-http\n are \"official\" modules and integral to the Arachne system; however, the hope is that Arachne will also develop a thriving ecosystem of third-party and open-source modules.\n\n\nAt a concrete level, an Arachne module is a Maven artifact containing Clojure code (or AOT compiled class files), packaged and delivered like any other. Modules can contain library code that users may call, just like any other Clojure library.\n\n\nThe distinguishing feature of an Arachne module compared to any other Clojure library is that each module JAR has an \narachne.edn\n file at the root of the classpath, containing metadata about the module, its dependencies and its hooks into the Arachne system.\n\n\nModules may declare dependencies on other modules, and an Arachne \napplication\n may depend on any number of modules. Only modules that are directly or transitively required by a given application are considered to be \"active\"; merely being present on the classpath is not sufficient to cause a module to be active in a given system.\n\n\nModules have hooks that allow active modules to participate in an Arachne system in a variety of ways. Specifically, these hooks are:\n\n\n\n\nschema\n: Each active module provides some configuration \nschema\n, defining the concepts, entity types and data that it exposes or expects to be present in the configuration. Modules may reference entities or attributes defined in the schema of modules that they depend upon.\n\n\ninitializers\n: When creating a configuration, after the schema is installed, each module has an opportunity to transact some initial data to the configuration. Module initializers are applied in dependency order: that is, the initializers of required modules are applied before the initalizers of the modules that depend upon them.\n\n\nconfigure\n: Each module also has the opportunity to query and update the configuration, \nafter\n modules that depend upon it have been initialized and configured. Module configuration is applied in reverse dependency order.\n\n\n\n\nIn addition, modules usually provide a library of DSL forms that make it easier to create and manipulate the configuration entities that they define in their schema.\n\n\nApplications\n\n\nAn Arachne application is just a special case of an Arachne module, where the module initializer is (usually) a user-supplied configuration script.\n\n\nThe API for initializing a new Arachne config requires users to specify the name of an Arachne application, which will be discovered in a classpath-relative \narachne.edn\n file in the same way that it is for modules.\n\n\nStartup Sequence\n\n\nBased on the above description of \nmodules\n and the \nruntime\n, the complete initialization and startup sequence for a specific Arachne application is as follows:\n\n\n\n\n\n\nBuilding the configuration\n\n\n\n\nA graph of active modules is determined, starting with the application and its dependencies.\n\n\nA schema is assembled by asking each active module if it has any schema to contribute (via its \nschema\n hook). A fresh configuration is built, with a schema that is the union of the active module schemas.\n\n\nIn dependency order, each module has the opportunity to update the fresh configuration using its \ninitializers\n hook. The application itself will have its initializers (including any user-supplied DSL scripts) called last.\n\n\nIn reverse dependency order, each module has the opportunity to query and update the configuration using its \nconfigure\n hook. The application will go first, and the module with the fewest dependencies (which will always be \narachne-core\n), last.\n\n\n\n\n\n\n\n\nInitializing the runtime\n\n\nThe configuration is passed to the runtime initializer function, which will instantiate all the components by calling their constructors.\n\n\n\n\n\n\n\nStarting the runtime\n\n\nEach component object will have it's \ncom.stuartsierra.component/start\n method called, in dependency order, after having all its own dependencies \nassoc\ned on.", 
            "title": "Architectural Overview"
        }, 
        {
            "location": "/architecture/#configuration", 
            "text": "Arachne is fundamentally data driven, and Arachne's architecture may be viewed as an experiment in taking a \"data-driven\" approach to its logical extreme.  Every Arachne application is defined, first and foremost, by its  configuration . The configuration defines every aspect of the application. This includes not only things that are traditionally \"config\" values like URLs, ports and connection info, but also much more fundamental aspects of the application including:   Dependency injection  HTTP Routes and endpoints  Database migrations  Asset processing  Anything else that can possibly be represented as data.   Because the configuration is so central to an Arachne app, it needs to be both easy and powerful to query and manipulate. To this end, the configuration is implemented as a full featured, in-memory  Datomic  (or  DataScript ) database.", 
            "title": "Configuration"
        }, 
        {
            "location": "/architecture/#schema", 
            "text": "Configurations have a schema, which is assembled from the schema of the included  modules . This schema is Datomic schema, enhanced with additional meta-attributes to provide a robust  entity type  model inspired by ontology definition languages such as  OWL .  The configuration schema is intended to define the  concepts  that can exist in an application, and the possible relationships between them.  So, while an Arachne configuration database describes a particular application in great detail, the configuration  schema  defines the set of  possible  applications for a given set of modules, and the choices that are available to application authors.", 
            "title": "Schema"
        }, 
        {
            "location": "/architecture/#config-initialization", 
            "text": "While a Datomic database is very powerful and has a great many virtues, being readable in its raw form is not one of them. Transaction data for complex entity structures is verbose and not very human friendly.  In order to fulfill its goal of being easy to use, Arachne provides a  configuration DSL  that allows users to write simple, idiomatic Clojure forms that incrementaly build an application configuration. In essence, these  configuration scripts  are a small Clojure program that writes the configuration, and the configuration is handed over to the  runtime  to be started once it is complete.", 
            "title": "Config Initialization"
        }, 
        {
            "location": "/architecture/#runtime", 
            "text": "A configuration is just data in a database. It doesn't actually  do  anything until it is used to initialize an Arachne runtime.  Configuration databases contain  component  entities. Component entities are database entities that correspond with actual software objects in a running application. Component entities define two important pieces of information:   Refs to other component entities (their  dependencies )  The fully-qualified name of a Clojure function that can be called to obtain an instance of the component.   When the runtime is started, it searches for all the component entities in the configuration, and builds a dependency graph. It then calls each component's constructor function to obtain an actual instance.  Components may be of any type, although it is required that they support Clojure's  clojure.lang.IPersistentMap  protocol (i.e, be a map or a record) if they are to have any dependencies, since dependencies are added by  assoc ing a keyword.  Component objects may also satisfy the  com.stuartsierra.Lifecycle  protocol from Stuart Sierra's \"Component\" library), implementing  start  and  stop  methods that will be called when the system is started and stopped, respectively.  Finally, the runtime wires each component together with its dependencies, and calls  start  on each of them in dependency order. At this point, the full Arachne system is running.  Note that an Arachne runtime is based off a single configuration  value . The configuration itself is immutable at that point. If the configuration needs to be changed, then a new runtime needs to be constructed.", 
            "title": "Runtime"
        }, 
        {
            "location": "/architecture/#modules", 
            "text": "Arachne is not a monolithic library. Any Arachne application is built from many different  modules , each implementing some feature set or providing some particular functionality. Some modules, such as the base  arachne-core  or  arachne-http  are \"official\" modules and integral to the Arachne system; however, the hope is that Arachne will also develop a thriving ecosystem of third-party and open-source modules.  At a concrete level, an Arachne module is a Maven artifact containing Clojure code (or AOT compiled class files), packaged and delivered like any other. Modules can contain library code that users may call, just like any other Clojure library.  The distinguishing feature of an Arachne module compared to any other Clojure library is that each module JAR has an  arachne.edn  file at the root of the classpath, containing metadata about the module, its dependencies and its hooks into the Arachne system.  Modules may declare dependencies on other modules, and an Arachne  application  may depend on any number of modules. Only modules that are directly or transitively required by a given application are considered to be \"active\"; merely being present on the classpath is not sufficient to cause a module to be active in a given system.  Modules have hooks that allow active modules to participate in an Arachne system in a variety of ways. Specifically, these hooks are:   schema : Each active module provides some configuration  schema , defining the concepts, entity types and data that it exposes or expects to be present in the configuration. Modules may reference entities or attributes defined in the schema of modules that they depend upon.  initializers : When creating a configuration, after the schema is installed, each module has an opportunity to transact some initial data to the configuration. Module initializers are applied in dependency order: that is, the initializers of required modules are applied before the initalizers of the modules that depend upon them.  configure : Each module also has the opportunity to query and update the configuration,  after  modules that depend upon it have been initialized and configured. Module configuration is applied in reverse dependency order.   In addition, modules usually provide a library of DSL forms that make it easier to create and manipulate the configuration entities that they define in their schema.", 
            "title": "Modules"
        }, 
        {
            "location": "/architecture/#applications", 
            "text": "An Arachne application is just a special case of an Arachne module, where the module initializer is (usually) a user-supplied configuration script.  The API for initializing a new Arachne config requires users to specify the name of an Arachne application, which will be discovered in a classpath-relative  arachne.edn  file in the same way that it is for modules.", 
            "title": "Applications"
        }, 
        {
            "location": "/architecture/#startup-sequence", 
            "text": "Based on the above description of  modules  and the  runtime , the complete initialization and startup sequence for a specific Arachne application is as follows:    Building the configuration   A graph of active modules is determined, starting with the application and its dependencies.  A schema is assembled by asking each active module if it has any schema to contribute (via its  schema  hook). A fresh configuration is built, with a schema that is the union of the active module schemas.  In dependency order, each module has the opportunity to update the fresh configuration using its  initializers  hook. The application itself will have its initializers (including any user-supplied DSL scripts) called last.  In reverse dependency order, each module has the opportunity to query and update the configuration using its  configure  hook. The application will go first, and the module with the fewest dependencies (which will always be  arachne-core ), last.     Initializing the runtime  The configuration is passed to the runtime initializer function, which will instantiate all the components by calling their constructors.    Starting the runtime  Each component object will have it's  com.stuartsierra.component/start  method called, in dependency order, after having all its own dependencies  assoc ed on.", 
            "title": "Startup Sequence"
        }, 
        {
            "location": "/tutorials/creating-a-project/", 
            "text": "Creating an Arachne Project\n\n\n\nThis in-depth tutorial describes how to create a simple Arachne project from scratch, explaining everything as it goes. You can find the complete source code used in this tutorial on \nGithub\n.\n\n\nIn practice, you will probably want to start new Arachne projects using Arachne's project generator, as described on the main \ndocs page\n. However, when learning Arachne, it is instructive to go through this excercise and create each part piece by piece, to gain an understanding of what the parts are and how they work together.\n\n\nTo make the most of this particular tutorial, you will be most effective if you already:\n\n\n\n\nHave a basic knowledge of the Clojure language\n\n\nAre comfortable with Clojure protocols and records\n\n\nHave a Clojure editing environment that you are happy with. You should be able to launch a REPL, create Clojure source files, and evaluate forms from your source files in your REPL.\n\n\n\n\nCreating the project\n\n\nFor this tutorial, we'll use \nleiningen\n to assemble our dependencies and launch a JVM.\n\n\n\nOf course, you can also use Arachne with \nboot\n or any other Clojure build tool. We simply use lein for this tutorial since it's the most familiar to the most people.\n\n\n\n\nFirst, let's create a new lein project. At the command line, navigate to a directory of your choice and type \nlein new myproj\n. This will create a directory called \nmyproj\n containing a \nproject.clj\n file and several stubbed source and test files.\n\n\nFor this tutorial, we will not be using the \n/test\n, \n/doc\n, \nREADME.md\n, \nLICENSE\n or \nCHANGELOG.md\n files, so we will delete them to keep things crystal clear.\n\n\nAfter this step, your directory structure should be as follows:\n\n\nmyproj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj\n\n\n\n\nEdit the \nproject.clj\n file to contain the following contents:\n\n\n(defproject myproj \n0.1.0-SNAPSHOT\n\n  :dependencies [[org.clojure/clojure \n1.9.0-alpha14\n]\n                 [org.arachne-framework/arachne-core \narachne-core-version\n]\n                 [datascript \n0.15.5\n]\n                 [ch.qos.logback/logback-classic \n1.1.3\n]]\n  :source-paths [\nsrc\n \nconfig\n]\n  :repositories [[\narachne-dev\n\n                  \nhttp://maven.arachne-framework.org/artifactory/arachne-dev\n]])\n\n\n\n\nYou can just cut and paste for now, but if you're curious about what any of this means:\n\n\n\n\nArachne leverages the new \nclojure.spec\n library heavily, and therefore requires the latest alpha of Clojure 1.9\n\n\nThe version number for Arachne looks funky. WTF is \narachne-core-version\n supposed to mean? Well, instead of using SNAPSHOT builds that are effectively mutable and can change underneath you, Arachne's dev builds are named with the following format: \nsemver\n-\nbranch\n-\ncommit-idx\n-\ncommit-sha\n. This guarantees that there is a unique version number for each dev build, and you can compare any two versions by looking at the commit-idx: we know that \n0081\n is newer than \n0080\n and older than \n0082\n. Eventually, we'll move to regular release versions, but for now working with dev builds is the best way to stay up-to-date. See the \nVersions\n page for a list of all the most recent development versions.\n\n\nWe've included DataScript on the classpath, but we also could have used \nDatomic\n or \nDatomic Free\n. Arachne will detect which one is on your classpath and use whatever is present (there is also a way to specify explicitly which to use, if your project includes both Datomic and Datascript.)\n\n\nIn addition to your project source code, Arachne uses config scripts, conventionally stored in a directory named \nconfig\n. If you want these on the classpath, you have to specify this in leiningen.\n\n\nLogging is provided by SLF4J, which is compatible with the logging used by most Clojure products (such as Datomic itself.) We can use any concrete logger that supports SLF4J. Logback is merely a common choice.\n\n\nWe need to add the \narachne-dev\n repository explicitly, since Arachne is not yet deployed into Clojars or any other public maven repository.\n\n\n\n\nWriting a component\n\n\nArachne uses Stuart Sierra's \"Component\" library as the foundation of its runtime system. Component defines the concept of a \"component\" (often called a \"SierraComponent\"), which is a (possibly stateful) object that can be started and stopped, as part of a larger system. SierraComponents can also have dependencies on eachother: more on that in the tutorial on \ndependency injection\n.\n\n\nTo get started with the simplest possible Arachne application, we need to do two things:\n\n\n\n\nCreate a SierraComponent that our system will use\n\n\nDefine a function which, when called, will return an instance of our component (a \"constructor\" function, in Arachne parlance)\n\n\n\n\nFirst, let's pop open \nsrc/myproj/core.clj\n and define a component (after requiring a couple namespaces):\n\n\n(ns myproj.core\n  (:require [com.stuartsierra.component :as c]\n            [arachne.log :as log]))\n\n(defrecord Widget []\n  c/Lifecycle\n  (start [this]\n    (log/info :msg \nHello, world!\n)\n    this)\n  (stop [this]\n    (log/info :msg \nGoodnight!\n)\n    this))\n\n\n\n\nThis is pretty straightforward; this code simply defines a component that satisfies Component's \nLifecycle\n protocol, and logs out a simple message when it is started and stopped, using Arachne's logging utility library.\n\n\nIf you want, at this point, you can verify that your component is working as expected using the REPL:\n\n\n(def w (-\nWidget))\n;;=\n #'myproj.core/w\n(c/start w)\n;;=\n #myproj.core.Widget{}\n21:29:50.867 [nREPL-worker-5] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nNow, all that's left is to define a constructor that, when invoked, will return an (unstarted) instance of our SierraComponent, fresh and ready to use:\n\n\n(defn make-widget\n  \nConstructor for a Widget\n\n  []\n  (-\nWidget))\n\n\n\n\nGreat! We're done here. Save the file and let's move on to the next step: creating an Arachne configuration.\n\n\nWriting a configuration script\n\n\nWhat is an Arachne configuration? Well, it's data that specifies everything about our application that can possibly be specified using data. And it's all in a database. Under the hood, our configuration is stored in a full-fledged, queryable Datomic (or DataScript) database, which makes it extremely powerful for modules to query and update under the hood.\n\n\nBut, building a configuration by directly creating a Datomic database is awkward. It isn't hard, but it's verbose, and not very readable. And since the configuration is what defines the basic structure of our application, we want it to be \nsuper\n readable.\n\n\nSo Arachne provides a DSL (domain specific language) oriented specifically towards writing configuration data. Instead of writing a database, you can just write a namespace containing a \nconfig script\n, and when the config namespace is loaded by Arachne, it will populate the config database with everything it needs.\n\n\nSo what does a config namespace look like? For our very simple app, it looks like this:\n\n\n(ns ^:config myproj.config\n    (:require [arachne.core.dsl :as a]))\n\n(a/id :myproj/widget-1 (a/component 'myproj.core/make-widget))\n\n(a/id :myproj/runtime (a/runtime [:myproj/widget-1]))\n\n\n\n\nSave this to a file called \nconfig/myproj/config.clj\n in your project directory.\n\n\nThere are two things worth unpacking here, before we dive into what these forms mean.\n\n\nFirst, you will notice that the namespace has some \n^:config\n metadata. This is to signal that although it is a valid Clojure namespace, it is \nnot part of your project's codebase\n. It is a config script, and serves a different purpose than does a standard Clojure namespace.\n\n\nIn a very real sense, your config script is an entirely separate mini-program that has only one job: generating a config. Your \nreal\n application will read that config and execute an application based on it. We happen to be using the same JVM for both programs, here, and using an \"in memory\" only config, because it's convenient. But it's theoretically possible to evaluate a config script, store the resulting config in a persistent database, shut down your computer, and then hand the config to an application and have it run at some point in the distant future.\n\n\nThis is also why the config code is in a separate directory, which we have added to the classpath in \nproject.clj\n. This further emphasizes its separation from the main application codebase.\n\n\nSecond, you can't evaluate these forms at the REPL. Sorry. This is because each time one of these config DSL forms is evaluated, it updates the \"current configuration\" (stored in an atom in a dynamic var, if you're curious how that works.) If you're just in a regular old REPL, there \nis\n no current configuration, and so trying to call a DSL form will throw an error. So you can't just require a config namespace from anywhere: Arachne needs to control the loading of config namespaces and make sure the correct environment is set up.\n\n\nWith that out of the way, let's talk about what these functions do.\n\n\narachne.core.dsl/id\n assigns an \"Arachne ID\" (a qualified keyword) to a an entity in the config. Arachne IDs are used pervasively to provide a human and machine-readable name to refer to config entities.\n\n\nThe \narachne.core.dsl/component\n function defines a component, in the configuration. The argument is a quoted symbol, identifying the constructor function to use when actually creating the component instance. Understand, the config DSL function only \nidentifies\n the constructor function; it isn't called yet! It's merely stored in the config, to be used when your app finally starts.\n\n\nThen, we use \narachne.core.dsl/id\n on the return value to name the component we just created, giving it an Arachne ID of \n:myproj/widget-1\n. So anywhere else we refer to \n:myproj/widget-1\n, we will be referring to that same config entity.\n\n\nThe \narachne.core.dsl/component\n function also takes an optional second argument, to specify the dependencies of the component, but we'll ignore that for now.\n\n\nThe \narachne.core.dsl/runtime\n function defines a named \nruntime entity\n in the application's configuration. The runtime entity groups components together and specifies which ones should be instantiated when an Arachne program starts. When we actually run our program, we'll see that we have to tell Arachne which runtime we want to use, which in turn indicates the set of components that we want started.\n\n\nIn this case we just have one runtime (named \n:myproj/runtime\n), which identifies our one and only component (\n:myproj/widget-1\n). But as applications get larger and more complex, it can be very useful to have multiple runtimes in the same config. For example, two different but related services could be defined in the same Arachne config, but have completely different runtimes, and do completely different things when started.\n\n\nApplication metadata\n\n\nFinally, we have to tell Arachne some metadata about our application: what its name is, what modules it depends on, and where our config script is located.\n\n\nTo do this, we need write an \narachne.edn\n file, somewhere on our classpath, that contains this information. Let's put it in \n/resources\n for now:\n\n\n[{:arachne/name :myproj/app\n  :arachne/inits [myproj.config]\n  :arachne/dependencies [:org.arachne-framework/arachne-core]}]\n\n\n\n\n\n\n:arachne/name\n is just the name of our application as a whole.\n\n\n:arachne/inits\n is a vector of  \"initializers\" to use. Initializers come in many flavors (for example, you can pass in raw Datomic transactions to the config) but here, we're just going to give it the name of the config namespace that we wrote in the previous section.\n\n\n:arachne/dependencies\n specifies the module names of the Arachne modules that we want to depend on. For this rudimentary example, that's just the core module, named \n:org.arachne-framework/arachne-core\n. All the modules we want to use must also be on the classpath (that is, specified in our \nproject.clj\n, which \narachne.core\n is.)\n\n\n\n\nThat's it! Our Arachne application is now ready to run.\n\n\nAt this point, your project directory structure should look like this:\n\n\nmyproj\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 myproj\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 config.clj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 arachne.edn\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj\n\n\n\n\nRunning the application\n\n\nThere are two ways to run an Arachne application:\n\n\n\n\nFrom the REPL, as you would during development\n\n\nFrom the command line, as you might in production\n\n\n\n\nRunning from the REPL\n\n\nWith a REPL open, start by requiring the namespaces we'll need to get things rolling:\n\n\n(require '[arachne.core :as arachne])\n(require '[com.stuartsierra.component :as c])\n\n\n\n\nThen, we can build a configuration value:\n\n\n(def cfg (arachne/config :myproj/app))\n;; =\n #'user/cfg\n\n\n\n\nInside this seemingly simple function call, a \nhuge\n number of things are happening under the hood.\n\n\n\n\nWe pass in only the name of our application, \n:myproj/app\n\n\nThe application metadata is loaded from the \narachne.edn\n file.\n\n\nA new config is built, using schema derived from all the modules that we depend on.\n\n\nOur config script is evaluated (you can put some \nprintln\ns in it, if you like, to prove to yourself that this is the case)\n\n\nAll the modules that we required are doing their thing, adding their own data to the config, and possibly querying and manipulating the data that we added.\n\n\n\n\nThe value that is returned is a configuration object: an immutable, in-memory database.\n\n\nSo far, we haven't actually started anything yet. To do that, we initialize a runtime using the config we just built:\n\n\n(def rt (arachne/runtime cfg :myproj/runtime))\n;; =\n #'user/rt\n\n\n\n\nWhat just happened? We gave the runtime initializer the configuration we want to use, and the Arachne ID of the runtime entity, within the config (remember)? What we got back was an initialized, but unstarted Arachne runtime object.\n\n\nAll of our constructor functions have been called (try putting a \nprintln\n in the constructor function to convince yourself that this is true), but we haven't yet called Component's \nstart\n method on our system, so nothing's actually happened yet. '\n\n\nLet's run it!\n\n\n(def started-rt (c/start rt))\n=\n #'user/started-rt\n\n\n\n\nNote that it's important to capture the result of calling \nstart\n; we'll need it to pass to \nstop\n if we ever want to stop our system.\n\n\nIn our console, we should also see two log messages:\n\n\n22:27:18.671 [nREPL-worker-20] INFO  arachne.core.runtime - {:msg \nStarting Arachne runtime\n, :line nil}\n22:27:18.675 [nREPL-worker-20] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nOne is the log message that Arachne spits out when it starts; the other is the log message from our component. It worked! We now have a full (if small) Arachne system running on our machine.\n\n\nYou can call \nstop\n on the runtime when you're done:\n\n\n(c/stop started-rt)\n22:33:23.754 [nREPL-worker-21] INFO  arachne.core.runtime - {:msg \nStopping Arachne runtime\n, :line nil}\n22:33:23.754 [nREPL-worker-21] INFO  myproj.core - {:msg \nGoodnight!\n, :line nil}\n\n\n\n\nThere are a few gotchas to remember when doing REPL-driven development with Arachne:\n\n\n\n\nIf you change anything in your config script, you'll need to stop your runtime and rebuild your config from \n(arachne.core/config)\n. The config that it returns is immutable, and can't be updated once it's been used to start a runtime.\n\n\nIf you change the code you use to define your component definitions, you'll have to re-initialize your runtime to see the changes, starting from \n(arachne.core/runtime)\n. Changing the definition of a component won't change the instances that are referenced inside the runtime object.\n\n\n\n\nIn the future, we plan to release dev tools that will watch source files and config scripts for changes and do some of these things automatically, but for now it's the responsibility of users to keep track of them.\n\n\nRunning from the command line\n\n\nRunning from the command line is, fortunately, even more straightforward. Arachne defines an \narachne.run\n namespace, which contains a \n-main\n method that can be used to easily launch an Arachne application.\n\n\nYou can set \narachne.run\n as the default \n:main\n namespace in leiningen by adding the following key to your \nproject.clj\n:\n\n\n:main arachne.run\n\n\n\n\nThen, you can start your Arachne application from the command line by calling \nlein run\n and passing it two arguments: the name of your application as defined in \narachne.edn\n, and the name of the runtime you want to start as defined in your init script:\n\n\nlein run :myproj/app :myproj/runtime\n22:46:01.744 [main] INFO  arachne.run - {:msg \nLaunching Arachne application\n, :name \n:myproj/app\n, :runtime \n:myproj/runtime\n, :line nil}\n22:46:03.498 [main] INFO  arachne.core.runtime - {:msg \nStarting Arachne runtime\n, :line nil}\n22:46:03.507 [main] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nYou should see the same log messages, indicating that the application (including your component) has started correctly.\n\n\nYou will need to terminate the program manually when you're done, since it won't exit by itself.\n\n\nError reporting\n\n\nThere is one final thing you should be aware of when developing an Arachne application: its enhanced error reporting tools.\n\n\nTo see what happens when something goes wrong, lets tweak our config script to pass an invalid name for our component: a keyword with no namespace:\n\n\n(a/id :widget-1 (a/component 'myproj.core/make-widget))\n\n\n\n\nWhen we try to build a config based on this script, it throws an exception:\n\n\n(def cfg (arachne/config :myproj/app))\n;;CompilerException arachne.ArachneException: Arguments to `arachne.core.dsl/id` did not conform to registered spec (type = :arachne.error/invalid-args), compiling:(myproj/config.clj:4:1)\n\n\n\n\nThis should look quite familiar to anyone who has experience with Clojure development... in that it isn't very helpful. Of course we can obtain a bit more information with some digging...\n\n\n(.printStackTrace *e)\n\narachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer)\n    at arachne.error$arachne_ex.invokeStatic(error.clj:132)\n    at arachne.error$arachne_ex.invoke(error.clj:123)\n\n   \nSNIP MANY MANY LINES\n\n\n    at arachne.core.module$initialize$fn__4038.invoke(module.clj:162)\n    ... 51 more\nCaused by: arachne.ArachneException: Arguments to `arachne.core.dsl/id` did not conform to registered spec (type = :arachne.error/invalid-args)\n    at arachne.error$arachne_ex.invokeStatic(error.clj:132)\n    at arachne.error$arachne_ex.invoke(error.clj:123)\n    at arachne.error$assert.invokeStatic(error.clj:60)\n    at arachne.error$assert.invoke(error.clj:53)\n    at arachne.error$assert_args.invokeStatic(error.clj:73)\n    at arachne.error$assert_args.doInvoke(error.clj:66)\n    at clojure.lang.RestFn.applyTo(RestFn.java:139)\n    at clojure.core$apply.invokeStatic(core.clj:659)\n    at clojure.core$apply.invoke(core.clj:652)\n    at arachne.core.dsl$id.invokeStatic(dsl.clj:47)\n    at arachne.core.dsl$id.doInvoke(dsl.clj:47)\n    at clojure.lang.RestFn.invoke(RestFn.java:421)\n    at myproj.config$eval9782.invokeStatic(config.clj:4)\n    at myproj.config$eval9782.invoke(config.clj:4)\n    at clojure.lang.Compiler.eval(Compiler.java:6978)\n    at clojure.lang.Compiler.load(Compiler.java:7430)\n    ... 78 more\nnil\n\n\n\n\nIf you manage to read through all that, you might eventually discover something helpful: it looks like there was something wrong with the arguments to \narachne.core.dsl/id\n. Fine.\n\n\nFortunately, with Arachne, there is a slightly better alternative: invoke \n(arachne.error/explain)\n, with no arguments, at the REPL. This will produce a pretty-printed view of the last top-level exception (the one currently bound to \n*e\n, in Clojure's REPL).\n\n\nThe output of \nexplain\n is still extremely verbose. It still lists the full stacktrace because, well, sometimes you need that. However, it is colored and highlighted in such a way that with a bit of scrolling you will eventually see something like this:\n\n\n\n\nHopefully, you find this to be a better alternative.\n\n\nOne of Arachne's goals is to provide good error messages, so if you find an error that is unhelpful or confusing, please consider it a bug and file an issue: we would love to get to a point where all error messages are not only clear and helpful, but illuminating on how the system as a whole is supposed to work.", 
            "title": "Creating a Project"
        }, 
        {
            "location": "/tutorials/creating-a-project/#creating-the-project", 
            "text": "For this tutorial, we'll use  leiningen  to assemble our dependencies and launch a JVM.  \nOf course, you can also use Arachne with  boot  or any other Clojure build tool. We simply use lein for this tutorial since it's the most familiar to the most people.  First, let's create a new lein project. At the command line, navigate to a directory of your choice and type  lein new myproj . This will create a directory called  myproj  containing a  project.clj  file and several stubbed source and test files.  For this tutorial, we will not be using the  /test ,  /doc ,  README.md ,  LICENSE  or  CHANGELOG.md  files, so we will delete them to keep things crystal clear.  After this step, your directory structure should be as follows:  myproj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj  Edit the  project.clj  file to contain the following contents:  (defproject myproj  0.1.0-SNAPSHOT \n  :dependencies [[org.clojure/clojure  1.9.0-alpha14 ]\n                 [org.arachne-framework/arachne-core  arachne-core-version ]\n                 [datascript  0.15.5 ]\n                 [ch.qos.logback/logback-classic  1.1.3 ]]\n  :source-paths [ src   config ]\n  :repositories [[ arachne-dev \n                   http://maven.arachne-framework.org/artifactory/arachne-dev ]])  You can just cut and paste for now, but if you're curious about what any of this means:   Arachne leverages the new  clojure.spec  library heavily, and therefore requires the latest alpha of Clojure 1.9  The version number for Arachne looks funky. WTF is  arachne-core-version  supposed to mean? Well, instead of using SNAPSHOT builds that are effectively mutable and can change underneath you, Arachne's dev builds are named with the following format:  semver - branch - commit-idx - commit-sha . This guarantees that there is a unique version number for each dev build, and you can compare any two versions by looking at the commit-idx: we know that  0081  is newer than  0080  and older than  0082 . Eventually, we'll move to regular release versions, but for now working with dev builds is the best way to stay up-to-date. See the  Versions  page for a list of all the most recent development versions.  We've included DataScript on the classpath, but we also could have used  Datomic  or  Datomic Free . Arachne will detect which one is on your classpath and use whatever is present (there is also a way to specify explicitly which to use, if your project includes both Datomic and Datascript.)  In addition to your project source code, Arachne uses config scripts, conventionally stored in a directory named  config . If you want these on the classpath, you have to specify this in leiningen.  Logging is provided by SLF4J, which is compatible with the logging used by most Clojure products (such as Datomic itself.) We can use any concrete logger that supports SLF4J. Logback is merely a common choice.  We need to add the  arachne-dev  repository explicitly, since Arachne is not yet deployed into Clojars or any other public maven repository.", 
            "title": "Creating the project"
        }, 
        {
            "location": "/tutorials/creating-a-project/#writing-a-component", 
            "text": "Arachne uses Stuart Sierra's \"Component\" library as the foundation of its runtime system. Component defines the concept of a \"component\" (often called a \"SierraComponent\"), which is a (possibly stateful) object that can be started and stopped, as part of a larger system. SierraComponents can also have dependencies on eachother: more on that in the tutorial on  dependency injection .  To get started with the simplest possible Arachne application, we need to do two things:   Create a SierraComponent that our system will use  Define a function which, when called, will return an instance of our component (a \"constructor\" function, in Arachne parlance)   First, let's pop open  src/myproj/core.clj  and define a component (after requiring a couple namespaces):  (ns myproj.core\n  (:require [com.stuartsierra.component :as c]\n            [arachne.log :as log]))\n\n(defrecord Widget []\n  c/Lifecycle\n  (start [this]\n    (log/info :msg  Hello, world! )\n    this)\n  (stop [this]\n    (log/info :msg  Goodnight! )\n    this))  This is pretty straightforward; this code simply defines a component that satisfies Component's  Lifecycle  protocol, and logs out a simple message when it is started and stopped, using Arachne's logging utility library.  If you want, at this point, you can verify that your component is working as expected using the REPL:  (def w (- Widget))\n;;=  #'myproj.core/w\n(c/start w)\n;;=  #myproj.core.Widget{}\n21:29:50.867 [nREPL-worker-5] INFO  myproj.core - {:msg  Hello, world! , :line nil}  Now, all that's left is to define a constructor that, when invoked, will return an (unstarted) instance of our SierraComponent, fresh and ready to use:  (defn make-widget\n   Constructor for a Widget \n  []\n  (- Widget))  Great! We're done here. Save the file and let's move on to the next step: creating an Arachne configuration.", 
            "title": "Writing a component"
        }, 
        {
            "location": "/tutorials/creating-a-project/#writing-a-configuration-script", 
            "text": "What is an Arachne configuration? Well, it's data that specifies everything about our application that can possibly be specified using data. And it's all in a database. Under the hood, our configuration is stored in a full-fledged, queryable Datomic (or DataScript) database, which makes it extremely powerful for modules to query and update under the hood.  But, building a configuration by directly creating a Datomic database is awkward. It isn't hard, but it's verbose, and not very readable. And since the configuration is what defines the basic structure of our application, we want it to be  super  readable.  So Arachne provides a DSL (domain specific language) oriented specifically towards writing configuration data. Instead of writing a database, you can just write a namespace containing a  config script , and when the config namespace is loaded by Arachne, it will populate the config database with everything it needs.  So what does a config namespace look like? For our very simple app, it looks like this:  (ns ^:config myproj.config\n    (:require [arachne.core.dsl :as a]))\n\n(a/id :myproj/widget-1 (a/component 'myproj.core/make-widget))\n\n(a/id :myproj/runtime (a/runtime [:myproj/widget-1]))  Save this to a file called  config/myproj/config.clj  in your project directory.  There are two things worth unpacking here, before we dive into what these forms mean.  First, you will notice that the namespace has some  ^:config  metadata. This is to signal that although it is a valid Clojure namespace, it is  not part of your project's codebase . It is a config script, and serves a different purpose than does a standard Clojure namespace.  In a very real sense, your config script is an entirely separate mini-program that has only one job: generating a config. Your  real  application will read that config and execute an application based on it. We happen to be using the same JVM for both programs, here, and using an \"in memory\" only config, because it's convenient. But it's theoretically possible to evaluate a config script, store the resulting config in a persistent database, shut down your computer, and then hand the config to an application and have it run at some point in the distant future.  This is also why the config code is in a separate directory, which we have added to the classpath in  project.clj . This further emphasizes its separation from the main application codebase.  Second, you can't evaluate these forms at the REPL. Sorry. This is because each time one of these config DSL forms is evaluated, it updates the \"current configuration\" (stored in an atom in a dynamic var, if you're curious how that works.) If you're just in a regular old REPL, there  is  no current configuration, and so trying to call a DSL form will throw an error. So you can't just require a config namespace from anywhere: Arachne needs to control the loading of config namespaces and make sure the correct environment is set up.  With that out of the way, let's talk about what these functions do.  arachne.core.dsl/id  assigns an \"Arachne ID\" (a qualified keyword) to a an entity in the config. Arachne IDs are used pervasively to provide a human and machine-readable name to refer to config entities.  The  arachne.core.dsl/component  function defines a component, in the configuration. The argument is a quoted symbol, identifying the constructor function to use when actually creating the component instance. Understand, the config DSL function only  identifies  the constructor function; it isn't called yet! It's merely stored in the config, to be used when your app finally starts.  Then, we use  arachne.core.dsl/id  on the return value to name the component we just created, giving it an Arachne ID of  :myproj/widget-1 . So anywhere else we refer to  :myproj/widget-1 , we will be referring to that same config entity.  The  arachne.core.dsl/component  function also takes an optional second argument, to specify the dependencies of the component, but we'll ignore that for now.  The  arachne.core.dsl/runtime  function defines a named  runtime entity  in the application's configuration. The runtime entity groups components together and specifies which ones should be instantiated when an Arachne program starts. When we actually run our program, we'll see that we have to tell Arachne which runtime we want to use, which in turn indicates the set of components that we want started.  In this case we just have one runtime (named  :myproj/runtime ), which identifies our one and only component ( :myproj/widget-1 ). But as applications get larger and more complex, it can be very useful to have multiple runtimes in the same config. For example, two different but related services could be defined in the same Arachne config, but have completely different runtimes, and do completely different things when started.", 
            "title": "Writing a configuration script"
        }, 
        {
            "location": "/tutorials/creating-a-project/#application-metadata", 
            "text": "Finally, we have to tell Arachne some metadata about our application: what its name is, what modules it depends on, and where our config script is located.  To do this, we need write an  arachne.edn  file, somewhere on our classpath, that contains this information. Let's put it in  /resources  for now:  [{:arachne/name :myproj/app\n  :arachne/inits [myproj.config]\n  :arachne/dependencies [:org.arachne-framework/arachne-core]}]   :arachne/name  is just the name of our application as a whole.  :arachne/inits  is a vector of  \"initializers\" to use. Initializers come in many flavors (for example, you can pass in raw Datomic transactions to the config) but here, we're just going to give it the name of the config namespace that we wrote in the previous section.  :arachne/dependencies  specifies the module names of the Arachne modules that we want to depend on. For this rudimentary example, that's just the core module, named  :org.arachne-framework/arachne-core . All the modules we want to use must also be on the classpath (that is, specified in our  project.clj , which  arachne.core  is.)   That's it! Our Arachne application is now ready to run.  At this point, your project directory structure should look like this:  myproj\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 myproj\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 config.clj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 arachne.edn\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj", 
            "title": "Application metadata"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-the-application", 
            "text": "There are two ways to run an Arachne application:   From the REPL, as you would during development  From the command line, as you might in production", 
            "title": "Running the application"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-from-the-repl", 
            "text": "With a REPL open, start by requiring the namespaces we'll need to get things rolling:  (require '[arachne.core :as arachne])\n(require '[com.stuartsierra.component :as c])  Then, we can build a configuration value:  (def cfg (arachne/config :myproj/app))\n;; =  #'user/cfg  Inside this seemingly simple function call, a  huge  number of things are happening under the hood.   We pass in only the name of our application,  :myproj/app  The application metadata is loaded from the  arachne.edn  file.  A new config is built, using schema derived from all the modules that we depend on.  Our config script is evaluated (you can put some  println s in it, if you like, to prove to yourself that this is the case)  All the modules that we required are doing their thing, adding their own data to the config, and possibly querying and manipulating the data that we added.   The value that is returned is a configuration object: an immutable, in-memory database.  So far, we haven't actually started anything yet. To do that, we initialize a runtime using the config we just built:  (def rt (arachne/runtime cfg :myproj/runtime))\n;; =  #'user/rt  What just happened? We gave the runtime initializer the configuration we want to use, and the Arachne ID of the runtime entity, within the config (remember)? What we got back was an initialized, but unstarted Arachne runtime object.  All of our constructor functions have been called (try putting a  println  in the constructor function to convince yourself that this is true), but we haven't yet called Component's  start  method on our system, so nothing's actually happened yet. '  Let's run it!  (def started-rt (c/start rt))\n=  #'user/started-rt  Note that it's important to capture the result of calling  start ; we'll need it to pass to  stop  if we ever want to stop our system.  In our console, we should also see two log messages:  22:27:18.671 [nREPL-worker-20] INFO  arachne.core.runtime - {:msg  Starting Arachne runtime , :line nil}\n22:27:18.675 [nREPL-worker-20] INFO  myproj.core - {:msg  Hello, world! , :line nil}  One is the log message that Arachne spits out when it starts; the other is the log message from our component. It worked! We now have a full (if small) Arachne system running on our machine.  You can call  stop  on the runtime when you're done:  (c/stop started-rt)\n22:33:23.754 [nREPL-worker-21] INFO  arachne.core.runtime - {:msg  Stopping Arachne runtime , :line nil}\n22:33:23.754 [nREPL-worker-21] INFO  myproj.core - {:msg  Goodnight! , :line nil}  There are a few gotchas to remember when doing REPL-driven development with Arachne:   If you change anything in your config script, you'll need to stop your runtime and rebuild your config from  (arachne.core/config) . The config that it returns is immutable, and can't be updated once it's been used to start a runtime.  If you change the code you use to define your component definitions, you'll have to re-initialize your runtime to see the changes, starting from  (arachne.core/runtime) . Changing the definition of a component won't change the instances that are referenced inside the runtime object.   In the future, we plan to release dev tools that will watch source files and config scripts for changes and do some of these things automatically, but for now it's the responsibility of users to keep track of them.", 
            "title": "Running from the REPL"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-from-the-command-line", 
            "text": "Running from the command line is, fortunately, even more straightforward. Arachne defines an  arachne.run  namespace, which contains a  -main  method that can be used to easily launch an Arachne application.  You can set  arachne.run  as the default  :main  namespace in leiningen by adding the following key to your  project.clj :  :main arachne.run  Then, you can start your Arachne application from the command line by calling  lein run  and passing it two arguments: the name of your application as defined in  arachne.edn , and the name of the runtime you want to start as defined in your init script:  lein run :myproj/app :myproj/runtime\n22:46:01.744 [main] INFO  arachne.run - {:msg  Launching Arachne application , :name  :myproj/app , :runtime  :myproj/runtime , :line nil}\n22:46:03.498 [main] INFO  arachne.core.runtime - {:msg  Starting Arachne runtime , :line nil}\n22:46:03.507 [main] INFO  myproj.core - {:msg  Hello, world! , :line nil}  You should see the same log messages, indicating that the application (including your component) has started correctly.  You will need to terminate the program manually when you're done, since it won't exit by itself.", 
            "title": "Running from the command line"
        }, 
        {
            "location": "/tutorials/creating-a-project/#error-reporting", 
            "text": "There is one final thing you should be aware of when developing an Arachne application: its enhanced error reporting tools.  To see what happens when something goes wrong, lets tweak our config script to pass an invalid name for our component: a keyword with no namespace:  (a/id :widget-1 (a/component 'myproj.core/make-widget))  When we try to build a config based on this script, it throws an exception:  (def cfg (arachne/config :myproj/app))\n;;CompilerException arachne.ArachneException: Arguments to `arachne.core.dsl/id` did not conform to registered spec (type = :arachne.error/invalid-args), compiling:(myproj/config.clj:4:1)  This should look quite familiar to anyone who has experience with Clojure development... in that it isn't very helpful. Of course we can obtain a bit more information with some digging...  (.printStackTrace *e)\n\narachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer)\n    at arachne.error$arachne_ex.invokeStatic(error.clj:132)\n    at arachne.error$arachne_ex.invoke(error.clj:123)\n\n    SNIP MANY MANY LINES \n\n    at arachne.core.module$initialize$fn__4038.invoke(module.clj:162)\n    ... 51 more\nCaused by: arachne.ArachneException: Arguments to `arachne.core.dsl/id` did not conform to registered spec (type = :arachne.error/invalid-args)\n    at arachne.error$arachne_ex.invokeStatic(error.clj:132)\n    at arachne.error$arachne_ex.invoke(error.clj:123)\n    at arachne.error$assert.invokeStatic(error.clj:60)\n    at arachne.error$assert.invoke(error.clj:53)\n    at arachne.error$assert_args.invokeStatic(error.clj:73)\n    at arachne.error$assert_args.doInvoke(error.clj:66)\n    at clojure.lang.RestFn.applyTo(RestFn.java:139)\n    at clojure.core$apply.invokeStatic(core.clj:659)\n    at clojure.core$apply.invoke(core.clj:652)\n    at arachne.core.dsl$id.invokeStatic(dsl.clj:47)\n    at arachne.core.dsl$id.doInvoke(dsl.clj:47)\n    at clojure.lang.RestFn.invoke(RestFn.java:421)\n    at myproj.config$eval9782.invokeStatic(config.clj:4)\n    at myproj.config$eval9782.invoke(config.clj:4)\n    at clojure.lang.Compiler.eval(Compiler.java:6978)\n    at clojure.lang.Compiler.load(Compiler.java:7430)\n    ... 78 more\nnil  If you manage to read through all that, you might eventually discover something helpful: it looks like there was something wrong with the arguments to  arachne.core.dsl/id . Fine.  Fortunately, with Arachne, there is a slightly better alternative: invoke  (arachne.error/explain) , with no arguments, at the REPL. This will produce a pretty-printed view of the last top-level exception (the one currently bound to  *e , in Clojure's REPL).  The output of  explain  is still extremely verbose. It still lists the full stacktrace because, well, sometimes you need that. However, it is colored and highlighted in such a way that with a bit of scrolling you will eventually see something like this:   Hopefully, you find this to be a better alternative.  One of Arachne's goals is to provide good error messages, so if you find an error that is unhelpful or confusing, please consider it a bug and file an issue: we would love to get to a point where all error messages are not only clear and helpful, but illuminating on how the system as a whole is supposed to work.", 
            "title": "Error reporting"
        }, 
        {
            "location": "/tutorials/http-requests/", 
            "text": "Handling HTTP Requests\n\n\n\nThis tutorial extends the project started in the \ngetting started tutorial\n and adds the Pedestal module. It shows how to define and start an HTTP server, and handle incoming HTTP requests using custom handlers functions.\n\n\nYou can find the complete source code used in this tutorial on \nGithub\n.\n\n\nTo make the most of this particular tutorial, you will be most effective if you have already read and understood the material in the \ngetting started tutorial\n\n\nEnabling the Pedestal module\n\n\nTo make our application into an HTTP server, we'll need to add the \narachne-pedestal\n Arachne module to our app. \nPedestal\n is an industrial strength HTTP server for Clojure, and Arachne wraps it, inheriting the benefits that it provides.\n\n\n\n\nThe \narachne-pedestal\n module uses Pedestal, as do many of Arachne's official modules, because we needed to pick \nsome\n http server and Pedestal fit the bill nicely. However, there's nothing about Arachne itself that requires Pedestal; in theory you could also (for example) build an \"arachne-ring\" module to fill the same role. Most of Arachne's container-agnostic HTTP concepts and handling code is already pulled out into a separate \narachne-http\n module (which \narachne-pedestal\n depends on) and could be freely reused.\n\n\nOf course, any modules that depend on \narachne-pedestal\n would then also need to be modified, or alternatives created.\n\n\n\n\n\nFirst, we'll need to add a Leiningen dependency, to make sure \narachne-pedestal\n is on our classpath. Because \narachne-pedestal\n ultimately depends on \narachne-core\n as well, we can actually \nreplace\n \narachne-core\n in the \nproject.clj\n: it will still be required.\n\n\nAfter adding it, your leiningen dependencies should look something like this:\n\n\n:dependencies [[org.clojure/clojure \n1.9.0-alpha14\n]\n               [org.arachne-framework/arachne-pedestal \narachne-pedestal-version\n]\n               [datascript \n0.15.5\n]\n               [ch.qos.logback/logback-classic \n1.1.3\n]]\n\n\n\n\nThen, we need to update the \narachne.edn\n file to indicate that our application should activate the Pedestal module. Just like \nproject.clj\n, we can actually replace the core module; because the Pedestal depends on it transitively, we no longer need depend on it explicitly.\n\n\n[{:arachne/name :myproj/app\n  :arachne/inits [myproj.config]\n  :arachne/dependencies [:org.arachne-framework/arachne-pedestal]}]\n\n\n\n\nWriting a handler function\n\n\nIn Arachne (and Pedestal) (and Ring), a handler function is a function which takes a request as its argument, and returns a response. Both the request and the response are represented as Clojure maps.\n\n\nBelow is what is possibly the simplest possible handler function. We will add it to our app, in \nsrc/myproj/core.clj\n:\n\n\n(defn hello-handler\n  [req]\n  {:status 200\n   :body \nHello, world!\n})\n\n\n\n\nThis function just responds with \n\"Hello, world!\"\n to any incoming request. Easy enough!\n\n\nThis is literally all of the project code we need to write to turn our application into a web application. Everything else will be defined in the Arachne configuration.\n\n\nServer configuration\n\n\nNow, for the interesting part: updating the config script to start an HTTP server serving up our handler.\n\n\nFirst, we will need to define a Component representing our handler function. Add the following to your config script:\n\n\n(require '[arachne.http.dsl :as h])\n\n(a/id :myproj/hello (h/handler 'myproj.core/hello-handler))\n\n\n\n\nThe \narachne.http.dsl/handler\n function looks very much like the \narachne.core.dsl/component\n function we used earlier. This is no accident! In fact, \nhandler\n is actually defining a component, too: just a specific kind of component. The difference is that the function specified should identify a handler function (the one we just wrote) instead of being a constructor that can return an arbitrary object. Note that we still need to give our handler component a name: \n:myproj/hello\n. We'll need to refer to this in the next step.\n\n\nNext, we will add some DSL forms that define an HTTP server, and tell it how to serve our handler function:\n\n\n(require '[arachne.pedestal.dsl :as p])\n\n(a/id :myproj/server\n  (p/server 8080\n\n    (h/endpoint :get \n/\n :myproj/hello)\n\n  ))\n\n\n\n\nThe \narachne.pedestal.dsl/server\n form creates yet another component entity named \n:myproj/server\n. Instead of passing a symbol that identifies a constructor or a handler function, \nserver\n requires a port.\n\n\nNested \ninside\n the server element, we declare an HTTP endpoint, using the \narachne.http.dsl/endpoint\n function. This function takes three arguments:\n\n\n\n\nThe HTTP method that this endpoint responds to, as a Clojure keyword. You may also pass a set of keywords if the endpoint can respond to multiple request types.\n\n\nThe route to which to \"attach\" the endpoint: requests to this route will be delegated to the endpoint.\n\n\nThe Arachne ID of the handler for this endpoint (which we declared above).\n\n\n\n\nIn general, this is how an Arachne applications always define their routing structure: A \nserver\n DSL form, with nested forms for all the endpoints inside.\n\n\nAgain, it cannot be emphasized enough: these DSL forms do not create an actual Pedestal server. They create entities in the config that define the server. No server is actually started, and no ports will be opened until we use this config to initialize a runtime and call \nstart\n.\n\n\nThere's just one more step: we need to tell Arachne that this HTTP server is part of our runtime, and should be started when the runtime starts. Replace the existing \na/runtime\n call with:\n\n\n(a/id :myproj/runtime (a/runtime [:myproj/server]))\n\n\n\n\nAt this point, your full configuration script should look something like this:\n\n\n(ns ^:config myproj.config\n  (:require [arachne.core.dsl :as a]\n            [arachne.http.dsl :as h]\n            [arachne.pedestal.dsl :as p]))\n\n(a/id :myproj/widget-1 (a/component 'myproj.core/make-widget))\n\n(a/id :myproj/runtime (a/runtime [:myproj/server]))\n\n(a/id :myproj/hello (h/handler 'myproj.core/hello-handler))\n\n(a/id :myproj/server\n  (p/server 8080\n\n    (h/endpoint :get \n/\n :myproj/hello)\n\n    ))\n\n\n\n\nRunning the server\n\n\nAt this point, we can start a runtime. But before we do, we should configure Logback to log a little bit less verbosely. If no \nlogback.xml\n file is supplied, the default log level is \nDEBUG\n, and Pedestal dumps a \nlot\n of debug messages. Copy and paste the following \nlogback.xml\n file into your \nresources\n directory to set a default log level of \nINFO\n and cut down on the noise:\n\n\nconfiguration debug=\nfalse\n\n\n    \nappender name=\nSTDOUT\n class=\nch.qos.logback.core.ConsoleAppender\n\n        \nencoder\n\n            \npattern\n%d{HH:mm:ss.SSS} %-5level - %logger{36} %msg%n\n/pattern\n\n        \n/encoder\n\n    \n/appender\n\n\n    \nroot level=\nINFO\n\n      \nappender-ref ref=\nSTDOUT\n/\n\n    \n/root\n\n\n\n/configuration\n\n\n\n\n\nThen, once logging is set up, we can run the server. Here, we'll use the command line (for simplicity), though of course you could use a REPL as described in the \ncreating a project\n tutorial.\n\n\nlein run :myproj/app :myproj/runtime\n\n\n\n\nAfter the version of Pedestal we specified in \nproject.clj\n is downloaded (if it isn't already installed on your system), you should see log output indicating that the server has started.\n\n\nHit the \nhttp://localhost:8080/\n URL to see your endpoint in action!\n\n\nPath params\n\n\nYou aren't limited to specific, hardcoded routes. Arachne (via Pedestal) also allows you to use a colon (similar to a Clojure keyword) to name a route segment, creating a \npath parameter\n. Values at that path are then available in the request, in a map under the \n:path-params\n key.\n\n\nLet's try it out with a new handler function:\n\n\n(defn greeter\n  [req]\n  (let [name (get-in req [:path-params :name])]\n    {:status 200\n     :body (str \nHello, \n name \n!\n)}))\n\n\n\n\nAnd the corresponding line in the configuration script, inside our server:\n\n\n(h/endpoint :get \n/greet/:name\n (h/handler 'myproj.core/greeter))\n\n\n\n\nThe \n:name\n key in the path indicates that any value at that URL should be bound to the \n:name\n key in the request's \n:path-params\n.\n\n\nAfter rebuilding the config and restarting the Arachne runtime, you should be able to see the new handler in action at \nhttp://localhost:8080/greet/Luke\n.\n\n\nYou may also notice that we've defined the endpoint in a different way than we did before. Instead of giving the handler component an Arachne ID and then referencing it by ID, we defined it anonymously and inline, declaring it \ninside\n the \nh/endpoint\n form.\n\n\nThat works fine! Arachne DSL functions which define components (including \narachne.core.dsl/component\n, \narachne.http.dsl/handler\n and \narachne.pedestal.dsl/server\n, that we've seen so far) all return the entity ID of their newly created config entity, in the context configuration. And DSL forms which reference another component (such as \narachne.http.dsl/endpoint\n) can accept either an Arachne ID, \nor\n an entity ID as a component identifier.\n\n\nThis means that the following three forms are equivalent:\n\n\n(h/endpoint :get \n/greet/:name\n (h/handler 'myproj.core/greeter))\n\n\n\n\n(def handler-eid (h/handler 'myproj.core/greeter))\n(h/endpoint :get \n/greet/:name\n handler-eid)\n\n\n\n\n(a/id :myproj/greeter (h/handler 'myproj.core/greeter))\n(h/endpoint :get \n/greet/:name\n :myproj/greeter)\n\n\n\n\nAnd, of course, we could both define a handler inline \nand\n give it an Arachne ID, because the \narachne.core.dsl/id\n function returns the entity ID to which it just assigned an Arachne ID:\n\n\n(h/endpoint :get \n/greet/:name\n (ai/id :myproj/greeter (h/handler 'myproj.core/greeter)))\n\n\n\n\nYou can use whichever of these variations leads to the cleanest and most readable config scripts.\n\n\nDo note, though, that if you don't give a component an Arachne ID, and you don't capture the return value of the DSL function, you've just created a component entity that you have no ability to refer to, which will be pretty useless to you.\n\n\nComponents and the runtime\n\n\nIf you were looking for it, you might also have noticed that we're not getting the \"Hello World\" message from our Widget component, which we built in the last tutorial. That's because when we edited our \n(a/runtime)\n form to include \n:myproj/server\n instead of \n:myproj/widget-1\n, we removed all references to the widget from the components we told Arachne to start. Because nothing was depending on it, it was neither instantiated nor started with the rest of the System.\n\n\nIf we did want to have our custom component to start up, we can add it to the runtime, along with our HTTP server, like so:\n\n\n(a/id :myproj/runtime (a/runtime [:myproj/server :myproj/widget-1]))\n\n\n\n\nNow, our custom component will start up alongside the server itself.\n\n\nFor much more on components and component dependencies, see the next tutorial on \ndependency injection\n.", 
            "title": "Handling HTTP Requests"
        }, 
        {
            "location": "/tutorials/http-requests/#enabling-the-pedestal-module", 
            "text": "To make our application into an HTTP server, we'll need to add the  arachne-pedestal  Arachne module to our app.  Pedestal  is an industrial strength HTTP server for Clojure, and Arachne wraps it, inheriting the benefits that it provides.   The  arachne-pedestal  module uses Pedestal, as do many of Arachne's official modules, because we needed to pick  some  http server and Pedestal fit the bill nicely. However, there's nothing about Arachne itself that requires Pedestal; in theory you could also (for example) build an \"arachne-ring\" module to fill the same role. Most of Arachne's container-agnostic HTTP concepts and handling code is already pulled out into a separate  arachne-http  module (which  arachne-pedestal  depends on) and could be freely reused.  Of course, any modules that depend on  arachne-pedestal  would then also need to be modified, or alternatives created.   First, we'll need to add a Leiningen dependency, to make sure  arachne-pedestal  is on our classpath. Because  arachne-pedestal  ultimately depends on  arachne-core  as well, we can actually  replace   arachne-core  in the  project.clj : it will still be required.  After adding it, your leiningen dependencies should look something like this:  :dependencies [[org.clojure/clojure  1.9.0-alpha14 ]\n               [org.arachne-framework/arachne-pedestal  arachne-pedestal-version ]\n               [datascript  0.15.5 ]\n               [ch.qos.logback/logback-classic  1.1.3 ]]  Then, we need to update the  arachne.edn  file to indicate that our application should activate the Pedestal module. Just like  project.clj , we can actually replace the core module; because the Pedestal depends on it transitively, we no longer need depend on it explicitly.  [{:arachne/name :myproj/app\n  :arachne/inits [myproj.config]\n  :arachne/dependencies [:org.arachne-framework/arachne-pedestal]}]", 
            "title": "Enabling the Pedestal module"
        }, 
        {
            "location": "/tutorials/http-requests/#writing-a-handler-function", 
            "text": "In Arachne (and Pedestal) (and Ring), a handler function is a function which takes a request as its argument, and returns a response. Both the request and the response are represented as Clojure maps.  Below is what is possibly the simplest possible handler function. We will add it to our app, in  src/myproj/core.clj :  (defn hello-handler\n  [req]\n  {:status 200\n   :body  Hello, world! })  This function just responds with  \"Hello, world!\"  to any incoming request. Easy enough!  This is literally all of the project code we need to write to turn our application into a web application. Everything else will be defined in the Arachne configuration.", 
            "title": "Writing a handler function"
        }, 
        {
            "location": "/tutorials/http-requests/#server-configuration", 
            "text": "Now, for the interesting part: updating the config script to start an HTTP server serving up our handler.  First, we will need to define a Component representing our handler function. Add the following to your config script:  (require '[arachne.http.dsl :as h])\n\n(a/id :myproj/hello (h/handler 'myproj.core/hello-handler))  The  arachne.http.dsl/handler  function looks very much like the  arachne.core.dsl/component  function we used earlier. This is no accident! In fact,  handler  is actually defining a component, too: just a specific kind of component. The difference is that the function specified should identify a handler function (the one we just wrote) instead of being a constructor that can return an arbitrary object. Note that we still need to give our handler component a name:  :myproj/hello . We'll need to refer to this in the next step.  Next, we will add some DSL forms that define an HTTP server, and tell it how to serve our handler function:  (require '[arachne.pedestal.dsl :as p])\n\n(a/id :myproj/server\n  (p/server 8080\n\n    (h/endpoint :get  /  :myproj/hello)\n\n  ))  The  arachne.pedestal.dsl/server  form creates yet another component entity named  :myproj/server . Instead of passing a symbol that identifies a constructor or a handler function,  server  requires a port.  Nested  inside  the server element, we declare an HTTP endpoint, using the  arachne.http.dsl/endpoint  function. This function takes three arguments:   The HTTP method that this endpoint responds to, as a Clojure keyword. You may also pass a set of keywords if the endpoint can respond to multiple request types.  The route to which to \"attach\" the endpoint: requests to this route will be delegated to the endpoint.  The Arachne ID of the handler for this endpoint (which we declared above).   In general, this is how an Arachne applications always define their routing structure: A  server  DSL form, with nested forms for all the endpoints inside.  Again, it cannot be emphasized enough: these DSL forms do not create an actual Pedestal server. They create entities in the config that define the server. No server is actually started, and no ports will be opened until we use this config to initialize a runtime and call  start .  There's just one more step: we need to tell Arachne that this HTTP server is part of our runtime, and should be started when the runtime starts. Replace the existing  a/runtime  call with:  (a/id :myproj/runtime (a/runtime [:myproj/server]))  At this point, your full configuration script should look something like this:  (ns ^:config myproj.config\n  (:require [arachne.core.dsl :as a]\n            [arachne.http.dsl :as h]\n            [arachne.pedestal.dsl :as p]))\n\n(a/id :myproj/widget-1 (a/component 'myproj.core/make-widget))\n\n(a/id :myproj/runtime (a/runtime [:myproj/server]))\n\n(a/id :myproj/hello (h/handler 'myproj.core/hello-handler))\n\n(a/id :myproj/server\n  (p/server 8080\n\n    (h/endpoint :get  /  :myproj/hello)\n\n    ))", 
            "title": "Server configuration"
        }, 
        {
            "location": "/tutorials/http-requests/#running-the-server", 
            "text": "At this point, we can start a runtime. But before we do, we should configure Logback to log a little bit less verbosely. If no  logback.xml  file is supplied, the default log level is  DEBUG , and Pedestal dumps a  lot  of debug messages. Copy and paste the following  logback.xml  file into your  resources  directory to set a default log level of  INFO  and cut down on the noise:  configuration debug= false \n\n     appender name= STDOUT  class= ch.qos.logback.core.ConsoleAppender \n         encoder \n             pattern %d{HH:mm:ss.SSS} %-5level - %logger{36} %msg%n /pattern \n         /encoder \n     /appender \n\n     root level= INFO \n       appender-ref ref= STDOUT / \n     /root  /configuration   Then, once logging is set up, we can run the server. Here, we'll use the command line (for simplicity), though of course you could use a REPL as described in the  creating a project  tutorial.  lein run :myproj/app :myproj/runtime  After the version of Pedestal we specified in  project.clj  is downloaded (if it isn't already installed on your system), you should see log output indicating that the server has started.  Hit the  http://localhost:8080/  URL to see your endpoint in action!", 
            "title": "Running the server"
        }, 
        {
            "location": "/tutorials/http-requests/#path-params", 
            "text": "You aren't limited to specific, hardcoded routes. Arachne (via Pedestal) also allows you to use a colon (similar to a Clojure keyword) to name a route segment, creating a  path parameter . Values at that path are then available in the request, in a map under the  :path-params  key.  Let's try it out with a new handler function:  (defn greeter\n  [req]\n  (let [name (get-in req [:path-params :name])]\n    {:status 200\n     :body (str  Hello,   name  ! )}))  And the corresponding line in the configuration script, inside our server:  (h/endpoint :get  /greet/:name  (h/handler 'myproj.core/greeter))  The  :name  key in the path indicates that any value at that URL should be bound to the  :name  key in the request's  :path-params .  After rebuilding the config and restarting the Arachne runtime, you should be able to see the new handler in action at  http://localhost:8080/greet/Luke .  You may also notice that we've defined the endpoint in a different way than we did before. Instead of giving the handler component an Arachne ID and then referencing it by ID, we defined it anonymously and inline, declaring it  inside  the  h/endpoint  form.  That works fine! Arachne DSL functions which define components (including  arachne.core.dsl/component ,  arachne.http.dsl/handler  and  arachne.pedestal.dsl/server , that we've seen so far) all return the entity ID of their newly created config entity, in the context configuration. And DSL forms which reference another component (such as  arachne.http.dsl/endpoint ) can accept either an Arachne ID,  or  an entity ID as a component identifier.  This means that the following three forms are equivalent:  (h/endpoint :get  /greet/:name  (h/handler 'myproj.core/greeter))  (def handler-eid (h/handler 'myproj.core/greeter))\n(h/endpoint :get  /greet/:name  handler-eid)  (a/id :myproj/greeter (h/handler 'myproj.core/greeter))\n(h/endpoint :get  /greet/:name  :myproj/greeter)  And, of course, we could both define a handler inline  and  give it an Arachne ID, because the  arachne.core.dsl/id  function returns the entity ID to which it just assigned an Arachne ID:  (h/endpoint :get  /greet/:name  (ai/id :myproj/greeter (h/handler 'myproj.core/greeter)))  You can use whichever of these variations leads to the cleanest and most readable config scripts.  Do note, though, that if you don't give a component an Arachne ID, and you don't capture the return value of the DSL function, you've just created a component entity that you have no ability to refer to, which will be pretty useless to you.", 
            "title": "Path params"
        }, 
        {
            "location": "/tutorials/http-requests/#components-and-the-runtime", 
            "text": "If you were looking for it, you might also have noticed that we're not getting the \"Hello World\" message from our Widget component, which we built in the last tutorial. That's because when we edited our  (a/runtime)  form to include  :myproj/server  instead of  :myproj/widget-1 , we removed all references to the widget from the components we told Arachne to start. Because nothing was depending on it, it was neither instantiated nor started with the rest of the System.  If we did want to have our custom component to start up, we can add it to the runtime, along with our HTTP server, like so:  (a/id :myproj/runtime (a/runtime [:myproj/server :myproj/widget-1]))  Now, our custom component will start up alongside the server itself.  For much more on components and component dependencies, see the next tutorial on  dependency injection .", 
            "title": "Components and the runtime"
        }, 
        {
            "location": "/tutorials/dependency-injection/", 
            "text": "Components and Dependency Injection\n\n\n\nArachne provides a comprehensive story for structuring an application with components and dependency injection. This brief tutorial shows how to create custom components, and wire them together using Arachne's dependency injection.\n\n\nYou can find the complete source code used in this tutorial on \nGithub\n.\n\n\nIf you are interested in the formal definition of a component in Arachne, and more details about how they work, see the \nconceptual documentation\n for components in the documentation for the Arachne Core module.\n\n\nBuilding Components\n\n\nIn the \nfirst tutorial\n, we defined a basic component in our configuration using the \narachne.core.dsl/component\n DSL form:\n\n\n(a/id :myproj/widget-1 (a/component 'myproj.core/make-widget))\n\n\n\n\nA quick recap: this defines a component that invokes the \nmyproj.core/make-widget\n function during startup to actually obtain an instance of the component. Then, it is assigned an Arachne ID of \n:myproj/widget-1\n.\n\n\nIn this tutorial, we will replace this component with a new one that is actually meaningful, instead of a meaningless \"widget.\"\n\n\nWe're going to create a component which is a proxy to a public API (http://robohash.org) that creates cute robot avatars based on some input text. Each text string generates an image of a unique robot, based on the provided text. For example, the string \n\"Luke\"\n generates the following image:\n\n\n\n\nThis is called a \nvisual hash\n, creating easily-recognizable images that are different for every input stream.\n\n\nWhat we'll do is to build a service to serve these cute images from \nour\n webapp, hitting the RoboHash web api on the server side.\n\n\nComponent Implementation\n\n\nFirst, let's write some code that actually can retrieve the bits for the robot image. We'll do our work in a new \nmyproj.visual-hash\n namespace in the sample project.\n\n\nAstute observers will notice that we \ncould\n write this as a simple function, rather than a record. Sssssh. We're building an example. Besides, if we ever want to do something like provide an alternate service for robots, or provide more configuration options, having a full component will be useful.\n\n\n\nThe format for requesting a robot is a request to a URL of the form \nhttp://robohash.org/\nname\n, where \nname\n is the text we want to hash. The response will be a PNG image, as a byte stream.\n\n\nTo actually retrieve the file, we will use the \n.openStream\n method of the built in \njava.net.URL\n class, which returns a \njava.io.InputStream\n object. An \nInputStream\n is great in this context, because we can also pass it directly as the \n:body\n of a Ring response.\n\n\nThis means that a good protocol for our use is something like this:\n\n\n(defprotocol VisualHash\n  (vhash [this s] \nGiven a string, return an image (as an InputStream)\n))\n\n\n\n\nThen, we can define an implementation for our RoboHash component. The code should be very straightforward. We'll also go ahead and add a constructor function:\n\n\n(ns myproj.visual-hash\n  (:import [java.net URL]))\n\n(defprotocol VisualHash\n  (vhash [this s] \nGiven a string, return an image (as an InputStream)\n))\n\n(defrecord RoboHash []\n  VisualHash\n  (vhash [this s]\n    (let [url (URL. (str \nhttps://robohash.org/\n s))]\n      (.openStream url))))\n\n(defn new-robohash\n  \nConstructor function for a RoboHash\n\n  []\n  (-\nRoboHash))\n\n\n\n\nNote that we haven't implemented the \ncom.stuartsierra.component/Lifecycle\n protocol; that's fine. Our component is stateless, and so we don't need it. We'll see an example of writing a stateful component later on.\n\n\nConfiguration\n\n\nNow that we have all the code we need, we can define a component to our Arachne config. Replace the definition of \n:myproj/widget-1\n in your config builder script (\nconfig/myproj/config.clj\n).\n\n\n(a/id :myproj/robohash (a/component 'myproj.visual-hash/new-robohash))\n\n\n\n\nWe can then define a handler endpoint with a dependency on \n:myproj/robohash\n:\n\n\n(h/endpoint :get \n/robot/:name\n (h/handler 'myproj.core/robot\n                                  {:hash-component :myproj/robohash}))\n\n\n\n\nThis is just like the \"hello world\" handler we defined; the only difference is that we've added a \ndependency map\n as an additional argument to the \narachne.core.dsl/handler\n DSL function. For handlers, the dependency map is a map of \nkeys\n to \ncomponent references\n. The key is the key that will be added to the request map. The component reference may be either an Arachne ID (as it is here), or the entity ID of a component in the configuration.\n\n\nAfter cleaning up all the other references to \n:myproj/widget-1\n, the config DSL script should look like this:\n\n\n(ns ^:config myproj.config\n   (:require [arachne.core.dsl :as a]\n             [arachne.http.dsl :as h]\n             [arachne.pedestal.dsl :as p]))\n\n(a/id :myproj/robohash (a/component 'myproj.visual-hash/new-robohash))\n\n(a/id :myproj/runtime (a/runtime [:myproj/server]))\n\n(a/id :myproj/hello (h/handler 'myproj.core/hello-handler))\n\n(a/id :myproj/server\n  (p/server 8080\n\n    (h/endpoint :get \n/\n :myproj/hello)\n    (h/endpoint :get \n/greet/:name\n (h/handler 'myproj.core/greeter))\n    (h/endpoint :get \n/robot/:name\n (h/handler 'myproj.core/robot\n                                    {:hash-component :myproj/robohash}))\n    ))\n\n\n\n\nHandler Dependencies\n\n\nNow, all that remains is to actually implement the \n:myproj.core/robot\n handler function.\n\n\nBecause we defined it in the handler dependency map, we know that we'll have a \n:hash-component\n key available in each request, with our robot-building component as its value.\n\n\nWe just need to invoke the \nmyproj.visual-hash/vhash\n protocol function on our component and the string we want to hash, to get an \nInputStream\n that we can return as the response body.\n\n\n(defn robot\n  [req]\n  (let [name (get-in req [:path-params :name])\n        c (:hash-component req)]\n    {:status 200\n     :headers {\nContent-Type\n \nimage/png\n}\n     :body (myproj.visual/vhash c name)}))\n\n\n\n\nWe'll also need to set the content-type header, so the browser knows what kind of a byte stream we're sending it (we happen to know it's a PNG image.)\n\n\nAfter adding this handler and cleaning out the unused \"widget\" stuff, the final \nmyproj.core\n namespace should look something like this:\n\n\n(ns myproj.core\n  (:require [myproj.visual-hash :refer [vhash]]\n            [arachne.log :as log]))\n\n(defn robot\n  [req]\n  (let [name (get-in req [:path-params :name])\n        c (:hash-component req)]\n    {:status 200\n     :headers {\nContent-Type\n \nimage/png\n}\n     :body (vhash c name)}))\n\n(defn hello-handler\n  [req]\n  {:status 200\n   :body \nHello, world!\n})\n\n(defn greeter\n  [req]\n  (let [name (get-in req [:path-params :name])]\n    {:status 200\n     :body (str \nHello, \n name \n!\n)}))\n\n\n\n\nLet's try it out! Start your server and visit \nhttp://localhost:8080/robot/yourname\n to see what your name looks like when rendered by the RoboHash algorithm, served up by Arachne.\n\n\nComponent Dependencies\n\n\nThe power of components and dependency injection isn't really evident in this example, so far. As noted above, we could just as easily have written a simple Clojure function to call inline in our handler, no component dependency required.\n\n\nWhy, then, should we mess around with all this component business? Well, there can be many reasons, but one big one is \ndependency injection\n, or \ninversion of control\n, where users can swap in an alternate implementation of a dependecy, changing only the configuration.\n\n\nSo let's try it. Say that our service is getting extremely high request volumes, and http://robohash.org has threatened to start throttling or metering requests. How can we cut back on our calls to the RoboHash service, while also improving request times?\n\n\nWell, (we imagine), from analyzing our logs it looks like most of the traffic is generated by the same users hitting our site over and over. This sounds like a problem for caching!\n\n\nSo, let's write a component which satisfies the \nVisualHash\n protocol, but which caches responses so that we don't always have to hit the back-end service.\n\n\nTo do this, we'll have to implement the following logic:\n\n\n\n\nWhen we get a request for a name we haven't seen before, we hit the backend service and store the response, then return it.\n\n\nWhen we get a request for a name we \nhave\n seen before, we return the cached value.\n\n\nWe can't store \nInputStream\n objects, so we need a tool for converting from an \nInputStream\n to something we can store, and back again.\n\n\n\n\nThis also implies that our component is stateful, since it needs to store a mutable cache of values. Fortunately, Clojure makes this safe and easy, using an atom.\n\n\nFor reading \nInputStream\n objects into a value we can store, and then spitting them back out again, we will use the \norg.apache.commons.io.IOUtils\n class, which is already included in our project via a transitive Arachne dependency.\n\n\nFinally, rather than caching requests specifically to http://robohash.org and re-implementing the network logic we already wrote, we can use the existing \nRoboHash\n component as a \ndelegate\n, which has the pleasant side effect of making our caching component more pluggable as well (it will work out of the box with any other component that satisfies the \nVisualHash\n protocol.)\n\n\nArmed with this information we can define a new component in the \nmyproj.visual-hash\n namespace:\n\n\n(ns myproj.visual-hash\n  (:require [arachne.log :as log]\n            [com.stuartsierra.component :as component])\n  (:import [java.net URL]\n           [java.io InputStream ByteArrayInputStream]\n           [org.apache.commons.io IOUtils]))\n\n(defrecord CachingVisualHash [delegate cache]\n  component/Lifecycle\n  (start [this]\n    (assoc this :cache (atom {})))\n  (stop [this]\n    (dissoc this :cache))\n  VisualHash\n  (vhash [this key]\n    (if-let [bytes (get @cache key)]\n      (ByteArrayInputStream. bytes)\n      (let [bytes (IOUtils/toByteArray (vhash delegate key))]\n        (log/info :msg \nCachingVisualHash cache miss\n :key key)\n        (swap! cache assoc key bytes)\n        (ByteArrayInputStream. bytes)))))\n\n(defn new-cache\n  \nConstructor function for a CachingVisualHash\n\n  []\n  (map-\nCachingVisualHash {}))\n\n\n\n\nIn the Config\n\n\nWe now have the ability to construct a \nVisualHash\n component that caches values, delegating cache misses to \nanother\n \nVisualHash\n component. We can set this up by adding a dependency map to the \narachne.core.dsl/component\n DSL form:\n\n\n(a/id :myproj/hashcache (a/component 'myproj.visual-hash/new-cache {:delegate :myproj/robohash}))\n\n\n\n\nThe dependency map on a \ncomponent\n works basically the same as it does for a \nhandler\n, except instead of adding the dependency component onto each request, it is \nassoc\n'ed to the component instance itself immediately before its \nstart\n method is called. This means that the \n:delegate\n field which \nCachingVisualHash\n uses is present and in place before it is used.\n\n\nThen, we merely need to swap out \n:myproj/robohash\n for \n:myproj/hashcache\n in our handler to start using it:\n\n\n(h/endpoint :get \n/robot/:name\n (h/handler 'myproj.core/robot\n                                  {:hash-component :myproj/hashcache}))\n\n\n\n\nAfter starting the server, you should see the \"cache miss\" log message the first time you make a request to \nhttp://localhost:8080/robot/yourname\n, but not for subsequent requests. You should also notice that subsequent requests get a lot faster, since the bytes are served locally rather than reaching all the way back to \nhttps://robohash.org\n.\n\n\nThe important thing to note here is that between Arachne's configuration and the \nVisualHash\n protocol, we've drastically reduced the degree of coupling present in our program. We can freely switch back and forth between the \n:myproj/robohash\n and \n:myproj/hashcache\n components. If we had another visual hash source, we could easily create a component that would use it, and as long as it satisfied the \nVisualHash\n protocol, it would Just Work, even as a \ndelegate\n for a \nCachingVisualHash\n component.\n\n\nSummary\n\n\nComponents and dependency injection are an extremely important aspect of how large applications are built, and Arachne aims to make defining such components and their dependencies as obvious as possible. Components are the building blocks both of Arachne applications, and of Arachne modules.\n\n\nOne final note: In this tutorial we used \narachne.core.dsl/component\n directly. \ncomponent\n is useful, but is actually a very \"low-level\" way to define application components. In fact, almost everything in Arachne that you've seen already is a component, built using more specialized component constructors. Handlers, servers, databases, asset transformers... all components.\n\n\nThe point is, each Arachne module provides its own specialized components, and the DSL to put them in your config. Regardless of how you define them, an Arachne app is components all the way down. Understanding what components there are, and how they depend upon eachother is the first and most important step towards understanding any application.", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/tutorials/dependency-injection/#building-components", 
            "text": "In the  first tutorial , we defined a basic component in our configuration using the  arachne.core.dsl/component  DSL form:  (a/id :myproj/widget-1 (a/component 'myproj.core/make-widget))  A quick recap: this defines a component that invokes the  myproj.core/make-widget  function during startup to actually obtain an instance of the component. Then, it is assigned an Arachne ID of  :myproj/widget-1 .  In this tutorial, we will replace this component with a new one that is actually meaningful, instead of a meaningless \"widget.\"  We're going to create a component which is a proxy to a public API (http://robohash.org) that creates cute robot avatars based on some input text. Each text string generates an image of a unique robot, based on the provided text. For example, the string  \"Luke\"  generates the following image:   This is called a  visual hash , creating easily-recognizable images that are different for every input stream.  What we'll do is to build a service to serve these cute images from  our  webapp, hitting the RoboHash web api on the server side.", 
            "title": "Building Components"
        }, 
        {
            "location": "/tutorials/dependency-injection/#component-implementation", 
            "text": "First, let's write some code that actually can retrieve the bits for the robot image. We'll do our work in a new  myproj.visual-hash  namespace in the sample project.  Astute observers will notice that we  could  write this as a simple function, rather than a record. Sssssh. We're building an example. Besides, if we ever want to do something like provide an alternate service for robots, or provide more configuration options, having a full component will be useful.  The format for requesting a robot is a request to a URL of the form  http://robohash.org/ name , where  name  is the text we want to hash. The response will be a PNG image, as a byte stream.  To actually retrieve the file, we will use the  .openStream  method of the built in  java.net.URL  class, which returns a  java.io.InputStream  object. An  InputStream  is great in this context, because we can also pass it directly as the  :body  of a Ring response.  This means that a good protocol for our use is something like this:  (defprotocol VisualHash\n  (vhash [this s]  Given a string, return an image (as an InputStream) ))  Then, we can define an implementation for our RoboHash component. The code should be very straightforward. We'll also go ahead and add a constructor function:  (ns myproj.visual-hash\n  (:import [java.net URL]))\n\n(defprotocol VisualHash\n  (vhash [this s]  Given a string, return an image (as an InputStream) ))\n\n(defrecord RoboHash []\n  VisualHash\n  (vhash [this s]\n    (let [url (URL. (str  https://robohash.org/  s))]\n      (.openStream url))))\n\n(defn new-robohash\n   Constructor function for a RoboHash \n  []\n  (- RoboHash))  Note that we haven't implemented the  com.stuartsierra.component/Lifecycle  protocol; that's fine. Our component is stateless, and so we don't need it. We'll see an example of writing a stateful component later on.", 
            "title": "Component Implementation"
        }, 
        {
            "location": "/tutorials/dependency-injection/#configuration", 
            "text": "Now that we have all the code we need, we can define a component to our Arachne config. Replace the definition of  :myproj/widget-1  in your config builder script ( config/myproj/config.clj ).  (a/id :myproj/robohash (a/component 'myproj.visual-hash/new-robohash))  We can then define a handler endpoint with a dependency on  :myproj/robohash :  (h/endpoint :get  /robot/:name  (h/handler 'myproj.core/robot\n                                  {:hash-component :myproj/robohash}))  This is just like the \"hello world\" handler we defined; the only difference is that we've added a  dependency map  as an additional argument to the  arachne.core.dsl/handler  DSL function. For handlers, the dependency map is a map of  keys  to  component references . The key is the key that will be added to the request map. The component reference may be either an Arachne ID (as it is here), or the entity ID of a component in the configuration.  After cleaning up all the other references to  :myproj/widget-1 , the config DSL script should look like this:  (ns ^:config myproj.config\n   (:require [arachne.core.dsl :as a]\n             [arachne.http.dsl :as h]\n             [arachne.pedestal.dsl :as p]))\n\n(a/id :myproj/robohash (a/component 'myproj.visual-hash/new-robohash))\n\n(a/id :myproj/runtime (a/runtime [:myproj/server]))\n\n(a/id :myproj/hello (h/handler 'myproj.core/hello-handler))\n\n(a/id :myproj/server\n  (p/server 8080\n\n    (h/endpoint :get  /  :myproj/hello)\n    (h/endpoint :get  /greet/:name  (h/handler 'myproj.core/greeter))\n    (h/endpoint :get  /robot/:name  (h/handler 'myproj.core/robot\n                                    {:hash-component :myproj/robohash}))\n    ))", 
            "title": "Configuration"
        }, 
        {
            "location": "/tutorials/dependency-injection/#handler-dependencies", 
            "text": "Now, all that remains is to actually implement the  :myproj.core/robot  handler function.  Because we defined it in the handler dependency map, we know that we'll have a  :hash-component  key available in each request, with our robot-building component as its value.  We just need to invoke the  myproj.visual-hash/vhash  protocol function on our component and the string we want to hash, to get an  InputStream  that we can return as the response body.  (defn robot\n  [req]\n  (let [name (get-in req [:path-params :name])\n        c (:hash-component req)]\n    {:status 200\n     :headers { Content-Type   image/png }\n     :body (myproj.visual/vhash c name)}))  We'll also need to set the content-type header, so the browser knows what kind of a byte stream we're sending it (we happen to know it's a PNG image.)  After adding this handler and cleaning out the unused \"widget\" stuff, the final  myproj.core  namespace should look something like this:  (ns myproj.core\n  (:require [myproj.visual-hash :refer [vhash]]\n            [arachne.log :as log]))\n\n(defn robot\n  [req]\n  (let [name (get-in req [:path-params :name])\n        c (:hash-component req)]\n    {:status 200\n     :headers { Content-Type   image/png }\n     :body (vhash c name)}))\n\n(defn hello-handler\n  [req]\n  {:status 200\n   :body  Hello, world! })\n\n(defn greeter\n  [req]\n  (let [name (get-in req [:path-params :name])]\n    {:status 200\n     :body (str  Hello,   name  ! )}))  Let's try it out! Start your server and visit  http://localhost:8080/robot/yourname  to see what your name looks like when rendered by the RoboHash algorithm, served up by Arachne.", 
            "title": "Handler Dependencies"
        }, 
        {
            "location": "/tutorials/dependency-injection/#component-dependencies", 
            "text": "The power of components and dependency injection isn't really evident in this example, so far. As noted above, we could just as easily have written a simple Clojure function to call inline in our handler, no component dependency required.  Why, then, should we mess around with all this component business? Well, there can be many reasons, but one big one is  dependency injection , or  inversion of control , where users can swap in an alternate implementation of a dependecy, changing only the configuration.  So let's try it. Say that our service is getting extremely high request volumes, and http://robohash.org has threatened to start throttling or metering requests. How can we cut back on our calls to the RoboHash service, while also improving request times?  Well, (we imagine), from analyzing our logs it looks like most of the traffic is generated by the same users hitting our site over and over. This sounds like a problem for caching!  So, let's write a component which satisfies the  VisualHash  protocol, but which caches responses so that we don't always have to hit the back-end service.  To do this, we'll have to implement the following logic:   When we get a request for a name we haven't seen before, we hit the backend service and store the response, then return it.  When we get a request for a name we  have  seen before, we return the cached value.  We can't store  InputStream  objects, so we need a tool for converting from an  InputStream  to something we can store, and back again.   This also implies that our component is stateful, since it needs to store a mutable cache of values. Fortunately, Clojure makes this safe and easy, using an atom.  For reading  InputStream  objects into a value we can store, and then spitting them back out again, we will use the  org.apache.commons.io.IOUtils  class, which is already included in our project via a transitive Arachne dependency.  Finally, rather than caching requests specifically to http://robohash.org and re-implementing the network logic we already wrote, we can use the existing  RoboHash  component as a  delegate , which has the pleasant side effect of making our caching component more pluggable as well (it will work out of the box with any other component that satisfies the  VisualHash  protocol.)  Armed with this information we can define a new component in the  myproj.visual-hash  namespace:  (ns myproj.visual-hash\n  (:require [arachne.log :as log]\n            [com.stuartsierra.component :as component])\n  (:import [java.net URL]\n           [java.io InputStream ByteArrayInputStream]\n           [org.apache.commons.io IOUtils]))\n\n(defrecord CachingVisualHash [delegate cache]\n  component/Lifecycle\n  (start [this]\n    (assoc this :cache (atom {})))\n  (stop [this]\n    (dissoc this :cache))\n  VisualHash\n  (vhash [this key]\n    (if-let [bytes (get @cache key)]\n      (ByteArrayInputStream. bytes)\n      (let [bytes (IOUtils/toByteArray (vhash delegate key))]\n        (log/info :msg  CachingVisualHash cache miss  :key key)\n        (swap! cache assoc key bytes)\n        (ByteArrayInputStream. bytes)))))\n\n(defn new-cache\n   Constructor function for a CachingVisualHash \n  []\n  (map- CachingVisualHash {}))", 
            "title": "Component Dependencies"
        }, 
        {
            "location": "/tutorials/dependency-injection/#in-the-config", 
            "text": "We now have the ability to construct a  VisualHash  component that caches values, delegating cache misses to  another   VisualHash  component. We can set this up by adding a dependency map to the  arachne.core.dsl/component  DSL form:  (a/id :myproj/hashcache (a/component 'myproj.visual-hash/new-cache {:delegate :myproj/robohash}))  The dependency map on a  component  works basically the same as it does for a  handler , except instead of adding the dependency component onto each request, it is  assoc 'ed to the component instance itself immediately before its  start  method is called. This means that the  :delegate  field which  CachingVisualHash  uses is present and in place before it is used.  Then, we merely need to swap out  :myproj/robohash  for  :myproj/hashcache  in our handler to start using it:  (h/endpoint :get  /robot/:name  (h/handler 'myproj.core/robot\n                                  {:hash-component :myproj/hashcache}))  After starting the server, you should see the \"cache miss\" log message the first time you make a request to  http://localhost:8080/robot/yourname , but not for subsequent requests. You should also notice that subsequent requests get a lot faster, since the bytes are served locally rather than reaching all the way back to  https://robohash.org .  The important thing to note here is that between Arachne's configuration and the  VisualHash  protocol, we've drastically reduced the degree of coupling present in our program. We can freely switch back and forth between the  :myproj/robohash  and  :myproj/hashcache  components. If we had another visual hash source, we could easily create a component that would use it, and as long as it satisfied the  VisualHash  protocol, it would Just Work, even as a  delegate  for a  CachingVisualHash  component.", 
            "title": "In the Config"
        }, 
        {
            "location": "/tutorials/dependency-injection/#summary", 
            "text": "Components and dependency injection are an extremely important aspect of how large applications are built, and Arachne aims to make defining such components and their dependencies as obvious as possible. Components are the building blocks both of Arachne applications, and of Arachne modules.  One final note: In this tutorial we used  arachne.core.dsl/component  directly.  component  is useful, but is actually a very \"low-level\" way to define application components. In fact, almost everything in Arachne that you've seen already is a component, built using more specialized component constructors. Handlers, servers, databases, asset transformers... all components.  The point is, each Arachne module provides its own specialized components, and the DSL to put them in your config. Regardless of how you define them, an Arachne app is components all the way down. Understanding what components there are, and how they depend upon eachother is the first and most important step towards understanding any application.", 
            "title": "Summary"
        }, 
        {
            "location": "/tutorials/interceptors/", 
            "text": "Using Interceptors\n\n\nThe code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Request Interceptors"
        }, 
        {
            "location": "/tutorials/interceptors/#using-interceptors", 
            "text": "The code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Using Interceptors"
        }, 
        {
            "location": "/tutorials/serving-assets/", 
            "text": "Serving Static Assets\n\n\nThe code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Static Assets"
        }, 
        {
            "location": "/tutorials/serving-assets/#serving-static-assets", 
            "text": "The code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Serving Static Assets"
        }, 
        {
            "location": "/tutorials/cljs/", 
            "text": "Building \n Serving ClojureScript\n\n\nTodo: write me", 
            "title": "ClojureScript"
        }, 
        {
            "location": "/tutorials/cljs/#building-serving-clojurescript", 
            "text": "Todo: write me", 
            "title": "Building &amp; Serving ClojureScript"
        }, 
        {
            "location": "/tutorials/figwheel/", 
            "text": "Dynamic Development with Figwheel\n\n\nThe code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Figwheel"
        }, 
        {
            "location": "/tutorials/figwheel/#dynamic-development-with-figwheel", 
            "text": "The code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Dynamic Development with Figwheel"
        }, 
        {
            "location": "/modules/arachne-core/", 
            "text": "Arachne Core\n\n\n\nThe \n:org.arachne-framework/arachne-core\n module defines the basic high-level concepts and code used to bootstrap an Arachne application.\n\n\nConcepts\n\n\nConfiguration\n\n\nAn Arachne configuration is an immutable value backed by a Datomic/DataScript database that contains all the information about an application that can possibly be encoded as data.\n\n\nConcretely, an Arachne configuration is a value that satisfies the \narachne.core.config/Configuration\n protocol. All queries and updates to an Arachne configuration should go through this protocol rather than interacting with the underlying implementation.\n\n\nValid Arachne transaction data is transaction data that is compatible with either Datomic or DataScript. Arachne provides its own \narachne.core.config.Tempid\n type which must be used to provide a compatibility layer between the different tempid representations used by Datomic and DataScript.\n\n\nModules intended for public consumption should support (and test against) both Datomic and Datascript, to accommodate all users. Applications that are committed to one or the other may drop support for the unused implementation.\n\n\nConfigurations have a schema. The schema of a configuration is standard (Datomic-style) transaction data. Arachne Core also defines additional meta-attributes which add a basic type/ontology system to data in the config. The core configuration schema also supports transaction attributes indicating the provenance of all modifications to the config.\n\n\nApplications/Modules\n\n\nAn \napplication\n refers a piece of software built for a specific purpose, while \nmodules\n provide more generic, reusable functionality.\n\n\nAt the technical level, there is no difference between an Arachne application and an Arachne module. Throughout the rest of this documentation, the term \"module\" will be used. However, this should always be presumed to refer to applications as well unless otherwise noted.\n\n\nModules are defined by \narachne.edn\n files that must be on the root of the classpath (usually in a \nresources\n directory for applications, or directly in a JAR file for packaged modules.) Each \narachne.edn\n file contains a sequence of one or more module definition maps, each map defining one module.\n\n\nEach module definition map may contain the following keys:\n\n\n\n\n:arachne/name\n (required) - a namespace-qualified keyword uniquely identifying the module.\n\n\n:arachne/dependencies\n (required) - a sequence of the names of modules that this module depends upon. The total set of modules required by a given module or application forms a directed acyclic graph (DAG), a concept which is relied upon elsewhere.\n\n\n:arachne/schema\n (optional) - a fully qualified symbol identifying a function to be called when building a configuration. Presumed to return  transaction data containing configuration schema. Most commonly used by modules, although applications can define custom configuration schema for themselves as well.\n\n\narachne/inits\n (optional) - a seq of config \ninitializers\n, which provide initial configuration values. \nInitializers\n are applied when building a configuration, after the schema is built, but before \nconfigure functions\n. Initializers are applied in reverse dependency order: that is, for the specific application first and for the top-level \narachne-core\n module last. Valid values/types of initializers are enumerated below.\n\n\n:arachne/configure\n (optional) - a fully qualified symbol identifying a \nconfigure function\n. The configure function is passed a configuration value, and returns a (possibly updated) configuration value. Configure functions are applied when building a configuration, after the config \ninitializers\n. They are applied in dependency order: that is, for \narachne-core\n module first and for the specific application last.\n\n\n\n\nInitializer Types\n\n\nAn initializer (as defined in the module definition map) may be one of the following concrete types:\n\n\n\n\nA \nfully qualified symbol\n is interpreted as the name of a function, which is expected to take a configuration value and return a (possibly updated) configuration.\n\n\nAn \nunqualified symbol\n is interpreted as the name of a namespace, which will be loaded with the \narachne.core.config.script/*config*\n dynamic var bound to an atom containing the configuration. The presumption is that DSL forms in the config script will update the context configuration imperatively using \nswap!\n.\n\n\nA \nvector\n is assumed to be valid Datomic/DataScript transaction data and is transacted directly to the config.\n\n\nA \nstring\n is interpreted as the process-relative path to a configuration DSL script, which will be evaluated using Clojure's \nload-file\n function with a context config bound.\n\n\nAny other \nlist\n is evaluated by \neval\n as a config script (with \n*config*\n bound.)\n\n\n\n\nRuntime\n\n\nA \nruntime\n is the top-level executable unit of an Arachne application. While the word \"application\" or \"module\" is usually used to refer to the codebase and project structure, a \nruntime\n is a named entity that specifies exactly what should happen when it is started and stopped. A single application can contain any number of runtimes, and they may be started and stopped independently of eachother (as long as they do not attempt to utilize the same resources such as network ports).\n\n\nA runtime exists first as data in the configuration, a runtime \nentity\n that is defined along with the rest of the configuration. When a runtime is launched, the entity is used to instantiate an actual JVM object which is the runtime itself.\n\n\nRuntime Object\n\n\nA runtime object obtained by calling \narachne.core/runtime\n, and passing a configuration and the Arachne ID of a runtime entity. This will yield an instance of \narachne.runtime/ArachneRuntime\n, which satisfies \ncom.stuartsierra.component/Lifecycle\n.\n\n\nInstantiating an \nArachneRuntime\n will also instantiate all of the components that it depends upon, in an unstarted state. Calling \ncom.stuartsierra.component/start\n on the runtime will start the entire system, in dependency order.\n\n\nThis is the canonical way to start up an Arachne application.\n\n\nRuntime Entity\n\n\nA runtime entity is an entity in the configuration database that represents a \"runnable\" Arachne system, within a config. Runtime entities have only two important attributes:\n\n\n\n\nA runtime's \n:arachne/id\n serves to uniquely identify the runtime entity.\n\n\n:arachne.runtime/components\n is a ref that identifies one or more \ncomponents\n that are a \"part\" of the runtime.\n\n\n\n\nAlthough a configuration may contain multiple runtime entities as quiescent data, an actual Arachne instance must be initialized from just one of them. Only the components which are direct or transitive dependencies of the selected runtime will actually be instantiated and started.\n\n\nThis allows a configuration to contain multiple distinct systems.\n\n\nComponents\n\n\nA component is a software construct that fulfills a specific role in an program. For example, a typical webapp has components that represent the HTTP server, the database connection, each external service, and so on.\n\n\nComponents typically (but not always) have the following characteristics:\n\n\n\n\nThey encapsulate details of an application's behavior, exposing only salient top-level interfaces.\n\n\nThey form the structure of an application. An application may be viewed as a collection of components working together.\n\n\nThere are typically 1-2 instances of each component type, and they are often uniquely identifiable by name or description. This is in contrast with \"domain\" data or objects, of where there may be an an arbitrarily large number.\n\n\nThey are configured independently from one another; each component has its \"own\" configuration properties that pertain to it alone.\n\n\nThey are somewhat interchangeable; for example, a test environment may use an alternate component that mocks or stubs certain behaviors.\n\n\n\n\nThe concept of a component is particularly straightforward in object-oriented languages, where they often have 1:1 correspondence with the top-level objects of an object-oriented architecture. However, they are not unique to object-oriented programming. Rather, they are a fundamental effect of the need to keep large projects organized. Components are present (whatever the terminology used to refer to them) in large programs of every paradigm and programming language.\n\n\nComponents in Arachne\n\n\nIn Arachne, components are a first-class concept and Arachne defines the concept explicitly.\n\n\nArachne components, like everything else, are defined as entities in the config database. Component entities are entities of type \n:arachne/Component\n.\n\n\nBase Components may have the following attributes:\n\n\n\n\n:arachne/id\n is a qualified keyword that serves to uniquely name a component within a configuration. For components, an \n:arachne/id\n is optional.\n\n\n:arachne.component/constructor\n is mandatory. Under the hood, every component must have a constructor. This is a namespace-qualified keyword identifying a function that, when invoked, returns a runtime instance of the component.\n\n\n:arachne.component/dependencies\n is a ref to any number of dependency entities. Each dependency entity has two attributes: \narachne.core.component.dependency/ref\n is a reference to another component, and \n:arachne.core.component.dependency/key\n is a keyword. During the Arachne startup process, before each component is instantiated (by calling its constructor), the started instances of the components it depends on are \nassoc\n'd on using the specified key. If no key is specified, the dependency's entity ID is used as the key.\n\n\n\n\nDSL\n\n\nThe \narachne.core.dsl\n namespace defines the following config DSL functions, which operate on the context config.\n\n\n\n\nid\n allows you to assign an Arachne ID to a component.\n\n\ntransact\n allows you to apply transaction data directly.\n\n\ncomponent\n creates a component entity with the specified Arachne ID and constructor.\n\n\nruntime\n defines a runtime entity with the specified Arachne ID set of dependent components.", 
            "title": "arachne-core"
        }, 
        {
            "location": "/modules/arachne-core/#concepts", 
            "text": "", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-core/#configuration", 
            "text": "An Arachne configuration is an immutable value backed by a Datomic/DataScript database that contains all the information about an application that can possibly be encoded as data.  Concretely, an Arachne configuration is a value that satisfies the  arachne.core.config/Configuration  protocol. All queries and updates to an Arachne configuration should go through this protocol rather than interacting with the underlying implementation.  Valid Arachne transaction data is transaction data that is compatible with either Datomic or DataScript. Arachne provides its own  arachne.core.config.Tempid  type which must be used to provide a compatibility layer between the different tempid representations used by Datomic and DataScript.  Modules intended for public consumption should support (and test against) both Datomic and Datascript, to accommodate all users. Applications that are committed to one or the other may drop support for the unused implementation.  Configurations have a schema. The schema of a configuration is standard (Datomic-style) transaction data. Arachne Core also defines additional meta-attributes which add a basic type/ontology system to data in the config. The core configuration schema also supports transaction attributes indicating the provenance of all modifications to the config.", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-core/#applicationsmodules", 
            "text": "An  application  refers a piece of software built for a specific purpose, while  modules  provide more generic, reusable functionality.  At the technical level, there is no difference between an Arachne application and an Arachne module. Throughout the rest of this documentation, the term \"module\" will be used. However, this should always be presumed to refer to applications as well unless otherwise noted.  Modules are defined by  arachne.edn  files that must be on the root of the classpath (usually in a  resources  directory for applications, or directly in a JAR file for packaged modules.) Each  arachne.edn  file contains a sequence of one or more module definition maps, each map defining one module.  Each module definition map may contain the following keys:   :arachne/name  (required) - a namespace-qualified keyword uniquely identifying the module.  :arachne/dependencies  (required) - a sequence of the names of modules that this module depends upon. The total set of modules required by a given module or application forms a directed acyclic graph (DAG), a concept which is relied upon elsewhere.  :arachne/schema  (optional) - a fully qualified symbol identifying a function to be called when building a configuration. Presumed to return  transaction data containing configuration schema. Most commonly used by modules, although applications can define custom configuration schema for themselves as well.  arachne/inits  (optional) - a seq of config  initializers , which provide initial configuration values.  Initializers  are applied when building a configuration, after the schema is built, but before  configure functions . Initializers are applied in reverse dependency order: that is, for the specific application first and for the top-level  arachne-core  module last. Valid values/types of initializers are enumerated below.  :arachne/configure  (optional) - a fully qualified symbol identifying a  configure function . The configure function is passed a configuration value, and returns a (possibly updated) configuration value. Configure functions are applied when building a configuration, after the config  initializers . They are applied in dependency order: that is, for  arachne-core  module first and for the specific application last.", 
            "title": "Applications/Modules"
        }, 
        {
            "location": "/modules/arachne-core/#initializer-types", 
            "text": "An initializer (as defined in the module definition map) may be one of the following concrete types:   A  fully qualified symbol  is interpreted as the name of a function, which is expected to take a configuration value and return a (possibly updated) configuration.  An  unqualified symbol  is interpreted as the name of a namespace, which will be loaded with the  arachne.core.config.script/*config*  dynamic var bound to an atom containing the configuration. The presumption is that DSL forms in the config script will update the context configuration imperatively using  swap! .  A  vector  is assumed to be valid Datomic/DataScript transaction data and is transacted directly to the config.  A  string  is interpreted as the process-relative path to a configuration DSL script, which will be evaluated using Clojure's  load-file  function with a context config bound.  Any other  list  is evaluated by  eval  as a config script (with  *config*  bound.)", 
            "title": "Initializer Types"
        }, 
        {
            "location": "/modules/arachne-core/#runtime", 
            "text": "A  runtime  is the top-level executable unit of an Arachne application. While the word \"application\" or \"module\" is usually used to refer to the codebase and project structure, a  runtime  is a named entity that specifies exactly what should happen when it is started and stopped. A single application can contain any number of runtimes, and they may be started and stopped independently of eachother (as long as they do not attempt to utilize the same resources such as network ports).  A runtime exists first as data in the configuration, a runtime  entity  that is defined along with the rest of the configuration. When a runtime is launched, the entity is used to instantiate an actual JVM object which is the runtime itself.", 
            "title": "Runtime"
        }, 
        {
            "location": "/modules/arachne-core/#runtime-object", 
            "text": "A runtime object obtained by calling  arachne.core/runtime , and passing a configuration and the Arachne ID of a runtime entity. This will yield an instance of  arachne.runtime/ArachneRuntime , which satisfies  com.stuartsierra.component/Lifecycle .  Instantiating an  ArachneRuntime  will also instantiate all of the components that it depends upon, in an unstarted state. Calling  com.stuartsierra.component/start  on the runtime will start the entire system, in dependency order.  This is the canonical way to start up an Arachne application.", 
            "title": "Runtime Object"
        }, 
        {
            "location": "/modules/arachne-core/#runtime-entity", 
            "text": "A runtime entity is an entity in the configuration database that represents a \"runnable\" Arachne system, within a config. Runtime entities have only two important attributes:   A runtime's  :arachne/id  serves to uniquely identify the runtime entity.  :arachne.runtime/components  is a ref that identifies one or more  components  that are a \"part\" of the runtime.   Although a configuration may contain multiple runtime entities as quiescent data, an actual Arachne instance must be initialized from just one of them. Only the components which are direct or transitive dependencies of the selected runtime will actually be instantiated and started.  This allows a configuration to contain multiple distinct systems.", 
            "title": "Runtime Entity"
        }, 
        {
            "location": "/modules/arachne-core/#components", 
            "text": "A component is a software construct that fulfills a specific role in an program. For example, a typical webapp has components that represent the HTTP server, the database connection, each external service, and so on.  Components typically (but not always) have the following characteristics:   They encapsulate details of an application's behavior, exposing only salient top-level interfaces.  They form the structure of an application. An application may be viewed as a collection of components working together.  There are typically 1-2 instances of each component type, and they are often uniquely identifiable by name or description. This is in contrast with \"domain\" data or objects, of where there may be an an arbitrarily large number.  They are configured independently from one another; each component has its \"own\" configuration properties that pertain to it alone.  They are somewhat interchangeable; for example, a test environment may use an alternate component that mocks or stubs certain behaviors.   The concept of a component is particularly straightforward in object-oriented languages, where they often have 1:1 correspondence with the top-level objects of an object-oriented architecture. However, they are not unique to object-oriented programming. Rather, they are a fundamental effect of the need to keep large projects organized. Components are present (whatever the terminology used to refer to them) in large programs of every paradigm and programming language.", 
            "title": "Components"
        }, 
        {
            "location": "/modules/arachne-core/#components-in-arachne", 
            "text": "In Arachne, components are a first-class concept and Arachne defines the concept explicitly.  Arachne components, like everything else, are defined as entities in the config database. Component entities are entities of type  :arachne/Component .  Base Components may have the following attributes:   :arachne/id  is a qualified keyword that serves to uniquely name a component within a configuration. For components, an  :arachne/id  is optional.  :arachne.component/constructor  is mandatory. Under the hood, every component must have a constructor. This is a namespace-qualified keyword identifying a function that, when invoked, returns a runtime instance of the component.  :arachne.component/dependencies  is a ref to any number of dependency entities. Each dependency entity has two attributes:  arachne.core.component.dependency/ref  is a reference to another component, and  :arachne.core.component.dependency/key  is a keyword. During the Arachne startup process, before each component is instantiated (by calling its constructor), the started instances of the components it depends on are  assoc 'd on using the specified key. If no key is specified, the dependency's entity ID is used as the key.", 
            "title": "Components in Arachne"
        }, 
        {
            "location": "/modules/arachne-core/#dsl", 
            "text": "The  arachne.core.dsl  namespace defines the following config DSL functions, which operate on the context config.   id  allows you to assign an Arachne ID to a component.  transact  allows you to apply transaction data directly.  component  creates a component entity with the specified Arachne ID and constructor.  runtime  defines a runtime entity with the specified Arachne ID set of dependent components.", 
            "title": "DSL"
        }, 
        {
            "location": "/modules/arachne-http/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-http"
        }, 
        {
            "location": "/modules/arachne-http/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-http/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-pedestal/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-pedestal"
        }, 
        {
            "location": "/modules/arachne-pedestal/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-pedestal/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-assets/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-assets"
        }, 
        {
            "location": "/modules/arachne-assets/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-assets/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-cljs/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-cljs"
        }, 
        {
            "location": "/modules/arachne-cljs/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-cljs/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-figwheel/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-figwheel"
        }, 
        {
            "location": "/modules/arachne-figwheel/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-figwheel/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributor's Guide\n\n\nComing soon!", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributors-guide", 
            "text": "Coming soon!", 
            "title": "Contributor's Guide"
        }, 
        {
            "location": "/api/", 
            "text": "placeholder, API docs will be generated on top of this", 
            "title": "API Documentation"
        }
    ]
}